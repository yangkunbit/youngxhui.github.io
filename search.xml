<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[博客一周年]]></title>
      <url>%2F2017%2F04%2F20%2F%E5%8D%9A%E5%AE%A2%E4%B8%80%E5%91%A8%E5%B9%B4%2F</url>
      <content type="text"><![CDATA[2016年4月20日完成了博客搭建，今天2017年4月20日，博客已经维护运行一年。博客由 Github+Hexo 搭建，托管于 Github 。 在一年中，在 Github 上commits:179 ，star:5, fork:6 更新博客 30 篇。 其中访问量最大的是 Github 使用教程 系列。大多数的访问量都来源于这个系列博客。 总计评论为 46 条(可惜多说要关闭了，现在评论迁移到 disqus，国内IP无法访问) 截至十九点十分，百度统计最后统计 PV 为 39706 ，UV 为 13484 下图为 百度统计 其中文章的阅读量为 27000 下图为 leancould 统计 有来自 32 个国家或地区的IP HAPPY BIRTHDAY ISLAND]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyBatis入门基础]]></title>
      <url>%2F2017%2F04%2F17%2FMybatis%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[简介之前学了 Spring ， Spring-MVC 按着学习路线接下来的确应该看看 MyBatis ，毕竟要 ssm 。 在 Github 的主页上写到 MyBatis SQL Mapper Framework for Java The MyBatis SQL mapper framework makes it easier to use a relational database with object-oriented applications. MyBatis couples objects with stored procedures or SQL statements using a XML descriptor or annotations. Simplicity is the biggest advantage of the MyBatis data mapper over object relational mapping tools. 之前没有学过 Hibernate 据了解是不用写 Sql 语句的，有时间会去看看。之前用过 Spring的 JdbcTemperature 充分感觉到了这些框架比起之前直接写 SQL 语句的便利性。 MyBatis 历史MyBatis项目是iBATIS 3.0的子公司，由包括iBATIS原创创始人的团队维护。该项目于2010年5月19日创建，当时Apache iBATIS 3.0发布，该团队宣布，Google Code将以新名称和新主页继续发展。2013年11月10日，该项目宣布迁往Github 。 MyBatis 配置Jar包 mybatis-3.x.x.jarMaven Repository当前最新版本为 3.4.4 mysql 驱动包 XML配置 需要一个 xml 文件来作为 MyBatis 的全局配置文件。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="defaultStatementTimeout" value="3000"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;/settings&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="Pooled"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mysql2"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mapper/User.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; configuration 配置 setting 设置 environments 环境 environment 环境变量 transactionManager 事务管理 dataSource 数据库源 property 数据库配置 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017蓝桥杯]]></title>
      <url>%2F2017%2F04%2F15%2F2017%E8%93%9D%E6%A1%A5%E6%9D%AF%2F</url>
      <content type="text"><![CDATA[前言这是第二年参加蓝桥杯了。一年过去了，还是没有好好的学习算法。今年才意识到算法的重要性，所以立下一个 flag—手头这个项目做完就开始系统的学习一下算法。 相比于去年的 蓝桥杯，今年感觉提醒有点变化，不在是一味的暴力。数据量变大了，但是个人感觉没有意义。第一道题完全是个水题，按照出题意思应该是要从文件读取数据吧。可是我用了 Excel 。一分钟秒出答案。就连我这样的菜鸟都能做出来，不说了。 第二题 题目：用扑克牌 A,2,3,4,5,6,7,8,9组成一个三角形,使每条边的和相同三角形如下 A代表1，符合三边之和相等的一共有多少种情况？经过翻转，镜像为同一种的算一种！ 这个题首先要考虑的是镜像和翻转的情况.如图 这个为镜像 在考虑翻转和镜像问题后,同样的排列就会产生6种情况,我们需要在最后的结果除以6。 12345678910111213141516171819202122232425262728293031public class Tra &#123; static boolean[] flag = new boolean[9]; static int count = 0; static int[] a = new int[9]; public static void main(String[] args) &#123; dfs(0); System.out.println(count / 6); &#125; public static void dfs(int index) &#123; if (index == 9) &#123; int b1 = a[0] + a[1] + a[3] + a[5]; int b2 = a[0] + a[2] + a[4] + a[8]; int b3 = a[5] + a[6] + a[7] + a[8]; if (b1 == b2 &amp;&amp; b1 == b3) &#123; count++; &#125; &#125; for (int i = 0; i &lt; 9; i++) &#123; if (flag[i]) &#123; continue; &#125; flag[i] = true; a[index] = i; dfs(index + 1); flag[i] = false; &#125; &#125;&#125; 答案:144 第三题 又是一个数据量比较大的题，这个题是没有做出来的，回头自己再慢慢题解研究一下吧。这个题应该也是要从文件读取，而且当时没有找出什么规律。 第四题还是不会，一个拧魔方的题，要求是二阶魔方，目前还没有找到题，找到题后补上。 代码填空代码填空题略过，一般我做代码填空题是在所需要填写的位置打断点，根据 DEBUG 和输出要求来进行试探性的填写，一般不需要读懂全部代码，只需要知道部分代码即可，做题速度比较快。可惜，一不小心翻船了。 第五题所填写的空 f(x/10,k) 第六题答案 a[i-1][j-1]+1 船翻在了第六题，但是直接填写了 i 答案是测试是正常输出的。不知道给不给分。排除这个模棱两可的答案，前面一共做对了三道题。比去年是有点进步，但是发现还是很差啊。。。。。一定要好好研究算法。 第七题 标题：日期问题小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？ 输入一个日期，格式是”AA/BB/CC”。 (0 &lt;= A, B, C &lt;= 9) 输出输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列 输入02/03/04 样例输出2002-03-042004-02-032004-03-02资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 这个题说实话，其实不难，关键是考虑各种情况，比如是否闰年，年，月，日格式是否合法，最后还要有个排序。我没有写完，当时越写越烦，最后就成了能过多少测试过多少测试，完全成了骗分。 第八题 标题：包子凑数 小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种&gt; 蒸笼都有非常多笼，可以认为是无限笼。 每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有&gt; 3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个&gt; 的再加2笼4个的）。 当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个&gt; 包子时，大叔就凑不出来了。 小明想知道一共有多少种数目是包子大叔凑不出来的。 输入第一行包含一个整数N。(1 &lt;= N &lt;= 100)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100) 输出一个整数代表答案。如果凑不出的数目有无限多个，输出INF。 例如，输入：245 程序应该输出：6 再例如，输入：246 程序应该输出：INF 样例解释：对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。对于样例2，所有奇数都凑不出来，所以有无限多个。 刚刚开始的时候想的这个题使用除法，比如输入4和5两种包子，分别枚举出1~1000，用每个数去除以包子的情况，如果有余数，就用余数接着除。但是很快发现了不对。然后就叒变成了一个骗分题。把输入是偶数的情况先输出 INF。 总结最后的试题就写到了第八题，感觉今年的题应该是要比去年难的，明显不是暴力杯了。成绩很快出来了，省二。钱还没有白交，剩下就看看能不能申请学校的单项奖学金了。钱不是重要的，重要的是靠前的一周备考中还是学会了 DFS 。之前是不会这个算法的。有收获就好，记得自己立下的 Flag 。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[计蒜客蓝桥杯模拟赛(5)试题]]></title>
      <url>%2F2017%2F04%2F04%2F%E8%AE%A1%E8%92%9C%E5%AE%A2%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E8%B5%9B-5-%E8%AF%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[简介这是近期 计蒜客 的一个关于蓝桥杯的算法模拟赛。每个题进行一下简单的计算。 试题试题一 某君的年龄是个两位数，如果把他年龄的两位数字交换位置后与原数字相加和为 x，与原数字相减差的绝对值为 y。已知 x 比 y 大 32。请你计算 y 的值是多少。 这个试题很明显是一个送分题。通过手算就可以计算出这个答案。 答案：45 试题二 给出方程组： 11x+13y+17z=2471 13x+17y+11z=2739 已知 x，y，z 均为正整数，请你计算 x，y，z相加和最小为多少 这个题也是一个送分题,写个简单的暴力就可以算出。 123456789101112131415public class _2 &#123; public static void main(String[] args) &#123; int sum = 0; for (int x = 0; x &lt; 1000; x++) &#123; for (int y = 0; y &lt; 1000; y++) &#123; for (int z = 0; z &lt; 1000; z++) &#123; if (11 * x + 13 * y + 17 * z == 2471 &amp;&amp; 13 * x + 17 * y + 11 * z == 2739) &#123; sum = x + y + z; System.out.println(sum); &#125; &#125; &#125; &#125; &#125;&#125; 答案：181 试题三 将数字 1…9 填入一个3×3 的九宫格中，使得格子中每一横行和的值全部相等，每一竖列和的值全部相等。请你计 算有多少种填数字的方案。 这个还是一个暴力 1234567891011121314151617181920212223242526272829303132333435363738394041public class _3 &#123; public static void main(String[] args) &#123; int count = 0; int[] a = new int[9]; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (a[0] = 1; a[0] &lt; 10; a[0]++) &#123; for (a[1] = 1; a[1] &lt; 10; a[1]++) &#123; for (a[2] = 1; a[2] &lt; 10; a[2]++) &#123; for (a[3] = 1; a[3] &lt; 10; a[3]++) &#123; for (a[4] = 1; a[4] &lt; 10; a[4]++) &#123; for (a[5] = 1; a[5] &lt; 10; a[5]++) &#123; for (a[6] = 1; a[6] &lt; 10; a[6]++) &#123; for (a[7] = 1; a[7] &lt; 10; a[7]++) &#123; for (a[8] = 1; a[8] &lt; 10; a[8]++) &#123; int row1 = a[0] + a[1] + a[2]; int row2 = a[3] + a[4] + a[5]; int row3 = a[6] + a[7] + a[8]; int col1 = a[0] + a[3] + a[6]; int col2 = a[1] + a[4] + a[7]; int col3 = a[2] + a[5] + a[8]; if (col1 == col2 &amp;&amp; col2 == col3 &amp;&amp; row1 == row2 &amp;&amp; row1 == row3 &amp;&amp; col1 == row1) &#123; for (int i = 0; i &lt; 9; i++) &#123; set.add(a[i]); &#125; if (set.size() == 9) &#123; count++; &#125; set.clear(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; System.out.println(count); &#125;&#125; 答案：72]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python爬取斗鱼图片]]></title>
      <url>%2F2017%2F04%2F03%2Fpython%E7%88%AC%E5%8F%96%E6%96%97%E9%B1%BC%E5%9B%BE%E7%89%87%2F</url>
      <content type="text"><![CDATA[介绍一个简单的 Python 爬虫，用于爬取斗鱼网上的图片。 编辑工具：Visual Studio Code Python 版本：2.7 使用的库：urllib Visual Studio Code插件 Code Runner Python Python for VSCode MagicPython 实现思路首先要打开地址，并且获取该网页的代码。 从代码里获得你要图片。这里我们需要简单的分析一下该网页。 当我们把鼠标移到地址上的时候就会出现该图片，这个就是我们要爬取的图片。 这个图片是在 data-original 后面，我们就需要进行匹配，通过正则表达式很快就可以达到目的。 网页代码片段 1&lt;img data-original="https://rpic.douyucdn.cn/a1704/03/15/1032029_170403155245.jpg" src="https://rpic.douyucdn.cn/a1704/03/15/1032029_170403155245.jpg" width="283" height="163" style="display: block;"&gt; 正则表达式 data-original=&quot;(.*?\.(jpg|png)) 这样我们就获取到了这个页面上所有的 jpg 和 png 图片。 最后通过 urlretrieve 这个方法把图片保存到你想要放的地方。 代码12345678910111213141516171819# coding:utf8import urllibimport reimport time # 通过filename设置路径和名字response=urllib.urlopen('https://www.douyu.com/directory/game/TVgame')html=response.read()print htmlimglist=re.findall(r'data-original="(.*?\.(jpg|png))"',html)print imglistx=0for imgurl in imglist: print ('下载图片 %s'%imgurl[0]) if imgurl[1]=='gif': urllib.urlretrieve(imgurl[0],filename='G:\PythonCode\pic\%d.gif'%x) else: urllib.urlretrieve(imgurl[0],filename='G:\PythonCode\pic\%d.jpg'%x) x+=1 time.sleep(1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring学习记录(二)]]></title>
      <url>%2F2017%2F03%2F02%2FSpring%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[AOP简述面向切面编程，扩展功能不修改源代码实现。AOP采用横向抽取机制，取代了传统的纵向继承体系重复代码。 AOP底层原理AOP操作相关术语 链接点：类里面的被增强的方法。 切入点：类里面的增强的方法，在实际操作中，实际增强的方法叫切入点。 通知/增强：增强的逻辑，称为增强，比如扩展日志功能，这个日志功能称为增强。 前置通知：在方法之前执行 后置通知：在方法之后执行 异常通知：出现异之后执行 最终通知：在后置之后执行 环绕通知：在方法之前和之后执行 切面：把增强应用到具体的方法上面，这个过程称为切面。把增强用到切入点的过程。 Spring的AOP操作Aspectj框架在Spring进行aop操作，使用Aspectj框架，这个框架本身不是Spring的一部分，只是一起使用进行AOP操作。 版本在2.0以后支持切点表达式支持。 基于Aspectj实现AOP操作 相关ja包 aopalliance,aspectjweaver,spring-aop,spring-aspects 创建Spring核心配置文件导入AOP约束。1234567&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; 基于Aspectj的xml实现 常用表达式通过execution函数表达式实现。 execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution( /增强方法的全路径/): 代表任意修饰符，空格后跟随增强方法的全路径。 execution( com.Hello.):代表该类的所有方法 execution( .*(..)) execution( save(..)) 表示以save开头的方法进行增强。 xml配置代码123456789101112&lt;!--1.配置类--&gt; &lt;bean id="book" class="aop.Book"/&gt; &lt;bean id="myBook" class="aop.MyBook"/&gt; &lt;!--2.配置aop操作--&gt; &lt;aop:config&gt; &lt;!--2.1配置切入点--&gt; &lt;aop:pointcut id="pointcut1" expression="execution(* aop.Book.add())"/&gt; &lt;!--2.2配置切面--&gt; &lt;aop:aspect ref="myBook"&gt; &lt;aop:before method="before1" pointcut-ref="pointcut1"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 基于Aspectj的注解实现创建类的对象，在spring的配置文件中开启aop操作。 1&lt;aop:aspectj-autoproxy&gt; &lt;/aop:aspectj-autoproxy&gt; 通过注解来实现。 在增强类上@Aspect注解类，@Before注解方法(前置通知)。 @Before @AfterReturning @Around @AfterThrowing @After Spring的JdbcTemplate操作Spring在dao层，使用JdbcTemplate，Spring为各种支持的持久化技术，都提供了简单操作的模板和回调。 ORM持久化技术 模板类 JDBC org.springframework.jdbc.core.JdbcTemplate Hibemate5.0 org.springframework.orm.hibernate5.HibernateTemplate IBatis(MyBatis) org.springframework.orm.ibatis.sqlMapClientTempate JPA org.springframework.orm.jpa.JpaTempate JdbcTemplate使用都是对数据库进行crud操作。 导入JdbcTemplate相关jar包 spring-jdbc spring-tx 创建对象设置数据库信息，比如：加载驱动，设置url，用户名，密码等。实例代码 12345DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUsername("root"); dataSource.setUrl("jdbc:mysql://localhost:3306/JdbcDemo"); dataSource.setPassword("12qwaszx"); 创建JdbcTemplate模板对象，设置数据源。 1JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); 调用JdbcTemplate对象里面的方法实现操作。 添加12String sql = "INSERT INTO jdbcTest (id, name, password) VALUES (?,?,?)";jdbcTemplate.update(sql, "1", "lucy", "1234"); 修改1234String sql = "UPDATE jdbcTest\n" + "SET name = ?\n" + "WHERE id=?";jdbcTemplate.update(sql,"cat","1"); 删除12String sql = "DELETE FROM jdbcTest WHERE name=?";jdbcTemplate.update(sql,"cat"); 查询JdbcTemplate实现查询，有接口RowMapper,JdbcTemplate针对这个接口美欧提供实现类，等到不同的类型数据需要自己封装 查询一个值 123//查询返回某值 String sql1=&quot;SELECT count(*) FROM jdbcTest&quot;; int count=template.queryForObject(sql1,Integer.class); 返回对象 12345//查询返回对象 String sql2 = "select * from jdbcTest where name=?"; //调用jdbcTemplate方法 User user=template.queryForObject(sql2,new MyRowMapper() , "tom"); System.out.println(user); 要自己封装这个类其中querForObject这个方法的第二个值为RowMapper，需要自己进行封装。MyRowMapper.class12345678910111213class MyRowMapper implements RowMapper&lt;User&gt; &#123; @Override public User mapRow(ResultSet resultSet, int i) throws SQLException &#123;// 从结果集里面把数据得到 String username = resultSet.getString("name"); String password = resultSet.getString("password");// 把数据封装到对象里面 User user = new User(); user.setName(username); user.setPassword(password); return user; &#125;&#125; 返回list集合 123String sql3 = &quot;select * from jdbcTest&quot;;List&lt;User&gt; list = template.query(sql3, new MyRowMapper());System.out.println(list); Spring配置连接池和dao使用JdbcTemplate配置c3p0连接池 导入jar包 c3p0和mchange-commons-java 在Spring的配置文件配置连接池 在dao中使用 dao使用jdbctemplate 在Service中注入Dao。 在Dao中注入jdbc模板。 在模板中注入连接池。 在连接池中写配置。 示例代码 UserService.class 1234567891011121314151617package com.c3p0;/** * Created by youngxhui * Time is 17-2-19. */public class UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add()&#123; userDao.add(); &#125;&#125; UserDao.class 123456789101112131415161718192021package com.c3p0;import org.springframework.jdbc.core.JdbcTemplate;/** * Created by youngxhui * Time is 17-2-19. */public class UserDao &#123; private JdbcTemplate jdbcTemplate; public void add() &#123; String sql="INSERT INTO jdbcTest (id, name, password) VALUES (?,?,?)"; jdbcTemplate.update(sql, 5, "lili", "123456"); &#125; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125;&#125; SpringContext.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置c3p0的连接池--&gt; &lt;bean id="comboPooledDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/JdbcDemo"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="12qwaszx"/&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.c3p0.UserService"&gt; &lt;property name="userDao" ref="userDao"/&gt; &lt;/bean&gt; &lt;bean class="com.c3p0.UserDao" id="userDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"/&gt; &lt;/bean&gt; &lt;bean class="org.springframework.jdbc.core.JdbcTemplate" id="jdbcTemplate"&gt; &lt;property name="dataSource" ref="comboPooledDataSource"/&gt; &lt;/bean&gt;&lt;/beans&gt; Spring事务管理什么是事务事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换成另一种状态。 事务特性 原子性（atomicity） 一致性（consistency 隔离性 （isolation） 持久性（durability） Sping事务管理apispring对事务管理的两种方式 编程式事务管理(不用) 声明式事务管理 基于xml配置文件实现 基于注解实现 api介绍Spring事务管理高层抽象主要包含3个接口 PlatformTransactionManager事务管理器 TransactionDefinition事务定义信息 TransactionStatus事务具体运行状态 PlatformTransactionManager针对不同的dao层，提供了不同的接口实现类 事务 说明 org.springframework.idbc.datasource.DataSourceTransactionManager 使用Spring JDBC或iBatis进行持久化数据时使用 org.springframework.orm.hibernate5.HibernateTransactionManger 使用Hibernate5.0版本进行持久化数据时使用 org.springframework.orm.jpa.JpaTransactionManager 使用JPA进行持久化 org.springframework.jdo.JdoTransactionManager 当持久化机制是Jdo时使用 org.springframework.transaction.ita.JtaTransactionManager 使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Log4j使用]]></title>
      <url>%2F2017%2F02%2F19%2FLog4j%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[简介通过log4j可以看到程序运行时候更加详细的信息。 使用 导入log4j的jar包 复制log4j的配置文件 一个简单的log4j的配置文件 12345678910111213### 设置日志等级 ###log4j.rootLogger=info, stdout### 输出到控制台 ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.err#log4j.appender.stdout=System.errlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### 输出到日至文件log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=/home/youngxhui/IdeaProjects/SpringDemo/spring-aop-xml/src/mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n 设置日志级别 info：基本信息 debug：更详细的信息 实例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring学习(一)]]></title>
      <url>%2F2017%2F02%2F08%2FSpring%E5%AD%A6%E4%B9%A0-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Spring学习笔记，仅供自己参考。 概述 Spring是开源的轻量级框架。 Spring核心主要为两部分：(1).AOP:面向切面编程(2).IOC：控制反转： 把对象的创建不是通过new的方式实现，而是交给spring配置创建类对象 Spring是一站式框架。Spring在JavaEE三层结构中，每一层都提供不同的解决技术。 web层：SpringMVC service层：Spring的ioc dao层：Spring的jdbcTemplate Spring版本：4.x 接口 用于沟通的中介勿的抽象化。 对外声明。 Java 8中接口可以拥有方法体。 面向接口编程 结构设计中，分清层次及调用关系，每层只能向外提供一组功能接口，更层次仅依赖接口而非实现类。 接口实现的变动不影响各层的调用。 隐藏具体实现和实现多态性的组件。 IOC 控制反转什么是IOC控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。把对象的创建交给spring进行管理 IOC操作的两种操作 IOC的基于配置文件方式 IOC的注解方式 IOC的底层原理 xml的配置文件 dom4j解决xml 工厂设计模式 反射 IOC案例 导入jar包 核心jar包Beans Core Context, SpEL 支持日志输出的jar包 创建类，在类里面创建方法 创建spring的配置文件，配置创建类 建议放到src下面 测试对象创建 Spring的Bean管理(xml)实例化三种方式 使用类的无参构造(主要使用方式) 静态工厂创建 实例工厂创建 Bean标签常用属性 id属性 起名称，id的属性值可以是任意命名，但是不能包含特殊符号 class属性 创建对象所在类的全路径 name属性 功能和id属性是一样的，但是name属性可以包含特殊符号。 scope属性 singleton:默认值，单例对象。 prototupe:多例。 request:创建了对象，把对象放到request域里面。 session:创建对象，把对象放到session里面。 globalSession:创建对象，把对象放到globalSession里面。 Spring的Bean的管理(注解)注解 代码里面的特殊标记，使用注解可以完成功能。 注解写法@注解名称(属性名称=属性值)。 注解使用在类上面，方法上面和属性上面。 在xml需要配置一下1&lt;context:component-scan base-package="com.young.anno"/&gt; Bean管理常用注解 Component– 在Spring中提供的@Component三个衍生注解 @Controller WEB层 @Service 业务层 @Repository 持久层这四个注解目前的功能是一样的，都是创建对象。 123456@Component(value = "user")public class User &#123; public void add()&#123; System.out.println("add...."); &#125;&#125; Scope用于单例与多例等配置,写在Component的下面。 1234567@Component(value = "user")@Scope(value = "prototype") public class User &#123; public void add()&#123; System.out.println("add...."); &#125;&#125; Autowired注入属性 Resourcename属性写创建dao对象的value值 DI 依赖注入创建对象并且组装对象之间的关系 有参构造注入采用constructor-arg来进行,name和value进行对构造器的值进行注入。 123&lt;bean id="preperty" class="com.young.property.PrepertyDemo1"&gt; &lt;constructor-arg name="username" value="zhangsan"/&gt;&lt;/bean&gt; set方法注入使用property标签进行注入，name定义类里面定义的属性的名称，value设置具体的值 123&lt;bean id="book" class="com.young.property.Book"&gt; &lt;property name="bookname" value="one"/&gt;&lt;/bean&gt; spring框架只支持set方法注入和构造器注入 注入对象类型属性 创建service类dao类 在service把dao作为类型属性 生成dao类型的set方法 xml配置方式 UserService.java 1234567891011public class UserService &#123; private UserDao userDao; public void add()&#123; System.out.println("service"); userDao.add(); &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 配置文件 12345&lt;bean id="service" class="com.young.ioc.UserService"&gt; &lt;!--不能写value属性，要写ref,dao配置bean标签的id值--&gt; &lt;property name="userDao" ref="userdao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="userdao" class="com.young.ioc.UserDao"&gt; 注解注入方式 Autowired 1234567891011@Service(value = "userservice")public class UserService &#123; @Autowired private UserDao userDao; public void add()&#123; System.out.println("service"); userDao.add(); &#125;&#125; Resure UserDao.java 123456@Component(value = "userdao")public class UserDao &#123; public void add() &#123; System.out.println("UserDao"); &#125;&#125; 复杂类型注入 数组 123456789&lt;!--数组类型--&gt; &lt;property name="args"&gt; &lt;list&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小李子&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; list类型 123456&lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; map类型 12345&lt;property name="map"&gt; &lt;map&gt; &lt;entry key="a" value="张三"/&gt; &lt;/map&gt;&lt;/property&gt; properties 12345&lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="name"&gt;root&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; xml和注解比较 比较项 xml 注解 添加 &lt;Bean id=&quot;&quot; class=&quot;&quot;/&gt; @Component 多例/单例 &lt;Bean scope=&quot;prototype/&gt;&quot; @Scope 对象类型注入 &lt;bean id=&quot;&quot; class=&quot;&quot;&gt; &lt;property name=&quot;&quot;ref=&quot;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; @Resource 配置文件与注解混合使用案例： BookDao.java 12345public class BookDao &#123; public void book()&#123; System.out.println("bookDao"); &#125;&#125; OrderDao.java 12345public class BookDao &#123; public void book()&#123; System.out.println("bookDao"); &#125;&#125; BookService.java 12345678910111213public class BookService &#123; @Resource(name = "bookDao") private BookDao bookDao; @Resource(name = "ordlerDao") private OrderDao ordersDao; public void service()&#123; System.out.println("service"); bookDao.book(); ordersDao.buy(); &#125;&#125; 配置文件 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.young.xmlanno"/&gt; &lt;bean id="bookservice" class="com.young.xmlanno.BookService"/&gt; &lt;bean id="bookDao" class="com.young.xmlanno.BookDao"/&gt; &lt;bean id="ordlerDao" class="com.young.xmlanno.OrderDao"/&gt;&lt;/beans&gt; 测试类 12345678910111213import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; @org.junit.Test public void testxmlAnno()&#123; ApplicationContext context = new ClassPathXmlApplicationContext("bea2.xml"); BookService bookService= (BookService) context.getBean("bookservice"); bookService.service(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Junit单元测试]]></title>
      <url>%2F2017%2F01%2F19%2FJunit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[什么是Junit什么是Junit，Junit是用于java代码单元测试的框架。 为什么要用Junit简单的说，我们在写java代码的时候每次写完一个类，都要写一个public static void main(String args[])的方法来进行方法的调用，写完之后再删除，如果类比较多那么我们所创建的方法也比较多，操作起来比较麻烦。而Junit就是为了解决这种情况，他可以在一个类里面创建多个可运行的方法，来进行测试，这便是我们所使用Junit的原因。 如何使用我们在我们的项目中使用Junit需要先下载junit.jar包和hamcrest-core.jar并添加Github地址。这样我们就可以进行使用了。 示例代码我们创建了一个HelloWorld的类，类里面有sayHello这个方法，我们要对这个方法进行测试。12345public class HelloWorld &#123; public void sayHello()&#123; System.out.println("Hello"); &#125;&#125; 我们写一个类进行测试。 1234567public class HelloWorldTest &#123; @Test public void sayHello() throws Exception &#123; HelloWorld helloWorld = new HelloWorld(); helloWorld.sayHello(); &#125;&#125; 我们可以这样对sayHello方法就行测试。 但是，我们创建这个方法要满足一下要求。 方法必须是公用且无返回值(public void) 方法必须可以抛出异常throws Exception 方法必须用@test注解 这样我们就创建好了一个测试方法，并且我们可以在该类下写无数个这个的方法用于不同的测试。 IDEA演示 版本IDEA U 2016.3.1 首先我们先写好我们的HelloWorld类针对我们的sayHello方法进行测试，快捷键ctrl+shift+t这样我们就可以测试我们的方法了。 一般为了方便，我们会新建一个test文件夹。标记为test目录，这样自动生成的test类就会放到test目录中，不影响我们正常编写的代码。 结果如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven入门]]></title>
      <url>%2F2017%2F01%2F10%2FMaven%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[什么是MavenMaven是一个跨平台的项目管理工具，主要用于基于Java平台的项目构建，依赖管理。 maven之前的项目管理一般为 ant。 Maven的作用Maven的出现时为了解决项目的一些问题： 如果有好几个项目，这好几个项目中，需要用到很多相同的jar包，能不能只建立一个仓库来解决这个问题？ 测试方法能不能全部运行呢？ 怎么样把一个模块的功能放入到仓库中 Maven的安装和配置Maven的安装Jdk要求jdk要求1.7+ 下载Maven从Maven官网上下载最新版本的Maven 设定环境变量将下载好的Maven的bin追加到环境变量path中。 检查Maven是否配置成功在cmd中运行mvn -v，当出现下面的提示证明配置正确 注意：要用管理员权限运行cmd，否则会报错 建库Maven的很大作用就是导入jar包,所以我们建立一个仓库来放置项目所用的jar包，在需要的时候进行管理。 路径Maven的仓库默认路径是C:\Users\UserName\.m2 ,注：UserName为个人电脑名称 Maven的约定 路径 作用 src/main/java 存放项目的java文件 src/main/resources 存放项目的资源文件，如spring，hibernate的配置文件 src/test/java 存放所有的测试的java文件 src/test/resources 存放测试用的资源文件 target 项目输出位置 pom.xml 文件 必须按照这个约定放置 Maven项目知道了Maven的约定，那么我们就可以根据约定来进行创建第一个项目。在HelloWorld.java文件 1234567package com.young.maven.model;public class HelloWorld&#123; public String sayHello()&#123; return "HelloWorld"; &#125;&#125; HelloWorldTest.java文件 1234567891011package com.young.maven.model;import org.junit.*;import org.junit.Assert.*;public class HelloWorldTest&#123; @Test public void testHello()&#123; Assert.assertEquals("HelloWorld",new HelloWorld().sayHello()); &#125;&#125; pom.xml文件12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.young.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/project&gt; 在根目录下执行命令mvn compile这样就会编译成功。 Maven构建命令 命令 作用 mvn -v 查看maven版本 compile 编译 test 测试 package 打包 clean 删除target install 安装jar到本地仓库 Maven坐标123&lt;groupId&gt;&lt;/groupId&gt;&lt;artifactId&gt;&lt;/artifactId&gt;&lt;version&gt;&lt;/version&gt; 在Mevan中这三个就是基础坐标也是唯一的表示，可以快速定位到任何一个包 仓库 本地仓库 远程仓库 镜像仓库 如果Maven在本地仓库找不到构建，那么就会去Maven的中央仓库去寻找，如果Maven的中央仓库没有，就会报错。因为Maven的远程仓库在国外,常常无法访问或者很慢,这是我们就要使用一些镜像仓库,来帮助我们。在”~\apache-maven-3.3.9\conf\settings.xml”文件中，找到mirrors,我们可以修改这里进行镜像设置。 Maven中央仓库 中央仓库地址: http://repo.maven.apache.org/ pom.xml project是包含了pom的约束信息 modelVersion指定了当前pom的版本 groupId当前maven输入那个项目，包名+项目名 artifactId项目名+模块名version版本号，第一个0表示大版本号，第二个0表示分支版本号，第三个0表示小版本号。snapshot快照，alpha内部测试版本，beta公测版本，Relese稳定版本，GA正式发布版本。 packaging打包方式，默认为jar包，可以为war，zip name 项目描述 url项目地址，项目描述 developers 开发人员信息 licenses 许可信息 organization组织信息 1234567891011121314151617181920212223242526272829&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;scope&gt;依赖范围&lt;/scope&gt; &lt;!--设置依赖是否可选--&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!--排除依赖传递列表--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;parent&gt;&lt;/parent&gt;&lt;modules&gt;&lt;/modules&gt; #Maven依赖 依赖范围 scope 控制依赖和三种classpath的关系。 三种classpath 编译 测试 运行 scope一共有6个值分别为compile,provided,runtime,test,system,import。 名称 范围 compile 默认的范围，编译测试运行都要效。 provided 在编译和测试有效，运行时无效。 runtime 在测试和运行时有效 test 仅仅在测试有效 system 在本系统有效，移植性非常差 improt 导入范围，它只是用在dependencyManagement中，表示从其他pom.xml继承的依赖。 依赖传递例如MavenB项目依赖MavenA,而MavenC依赖于MavenB，这样的活那么MavenC就会依赖于MavenA。 依赖冲突A和B依赖不同版本但是相同的构建，就会出现冲突。 处理原则： 断路优先A-&gt;B -&gt; C -&gt;X(jar)A-&gt;D-&gt;X(jar)会优先解析路径短的。 先声明先优先如果两条路径一样，那么先声明的会先依赖。 Maven创建JavaWeb Maven IDEA 创建Maven项目,选择webapp填写好 GroupId和ArtifacetId之后next。这样我们就完成了一次创建。因为只为我们创建了resource目录，按照Maven的约定，我们需要创建其他目录。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年终总结]]></title>
      <url>%2F2016%2F12%2F30%2F2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[忙完了考试，课程设计，大创答辩，终于可以静下心来写一写今年的年终总结。 0x01 概况 只能感叹时光飞逝，一年又一年啊，记得去年写这个总结的时候还是在宿舍，午后阳光。那时刚好，今年写总结的地点已经变为了实验室。来说说这一年是怎么过来的吧。 0x02 蓝桥杯 去年元旦刚过，大一的我还不太懂事，那时的我应该是在准备蓝桥杯吧。比较紧张，也想着在这次比赛中获得一个好的成绩，虽说距离蓝桥杯还有一段时间，毕竟大一，想着准备充足一些，有种初生牛犊不怕虎的感觉。在准备蓝桥杯的同时也在准备考试。蓝桥杯的最后是没有任何名次……仅仅限于我，我不清楚最后改题是在我离开考场后改题，还是就没有通知，总之我是没有拿到任何名次，当时的感受都记录在这个博客里。第一次参加蓝桥杯的感受 0x03 实验室 实验室的加入对于我个人来说还是有所提升的，在大一学完c语言后，能每周写代码的人我觉得不超过20%，甚至比这个还少。很多人学完c语言后电脑就成了电视机，游戏机。也许我如果没有加入实验室可能会成为他们的一名。加入实验室的过程我还记得，比较痛苦的经历，熬了两天，把慕课网上的Java入门看完，勉勉强强的加入了实验室。大一上学期的我感觉是对程序刚刚有个了解而已，连入门都不敢说。加入实验室后，自己搭建了github+hexo博客，顺便了学会了git，github。认识github之后，真的如网上大神所说，打开了一个新世界的大门。实验室其实给我更多的是一种激励。说实话，在实验室仍然靠自学，自学能力提高了一个很高的程度，不仅仅在编程方面。我的小伙伴常常和我说：我感觉上了大学很多人的脑子都不动了，感觉他们退化了，变笨了。当然实验室的收获不仅仅是这点点。 0x04 Git/Github 可以毫不虚心的说，在我们这个这一届的实验室我是第一个了解并且使用GitHub的人，所以我写了一个关于Github入门系列的教程。不仅仅是为了实验室的同学，也是为了我与和我一样想学习Github难找到教程的人。也收获了每个月我的博客访问量达到了3000+。赠人玫瑰，手有余香。 0x05 Android 暑假前曾经一度想参加华北五省计算机应用大赛。于是开始了一个暑假的Android学习,学习过程并没有我想的那么一帆风顺，尤其是在新的控件学习中，在一个月的学习之后开始于小伙本尝试的做我们的应用，才发现我们仍旧什么都不会，直到现在，还是一种越学越多的感觉，总感觉还有很多新的知识要学习。 0x06 项目组 加入实验室之后，我发现越来越多的比赛想去尝试，想去报名，很多比赛需要一个团队去一起努力，组建一个团队是我大二一开始就出现的想法，也和好几个人讨论过，每次总是讨论到最后没有什么结论。知道上个月底，我开始了最后的突击。因为马上2016就要过去了，再不确立这一年过去，2017也会和这一样，一直拖。还好，最后项目组成立了。四个人可以负责两个前段，两个后端。项目组的组建应该说是刚刚赶上，为时不晚。 0x07 总结 2016年马上就要离去，总结2016的收获其实不少，缺失也是有的，唯有2017努力了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ArrayList源码分析]]></title>
      <url>%2F2016%2F11%2F27%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[概况ArrayList 是我们常用的一种数据结构。仔细分析 ArrayList 这个类和类所包含的方法。 签名ArrayList继承了AbstractList 和使用了List RandomAccess Cloneable和Serializable四个接口。 AbstractList该接口的作用是用于 AbstractList 提供了 List 接口的默认实现，在AbstractList中已经使用了List接口，为什么还会在ArrayList中使用的List接口，目测是为了让大家更加明白清楚的知道这个类是List这个集合。RandomAccess 是 变量ArrayList只有两个私有变量，分别是size和elementData。elementData这个是来记录传入ArrayList的元素。而size是用来记录传入的元素的个数。 构造器该类里面一共有三个构造器 ArrayList() ArrayList(int) ArrayList(Collection) 下面就详细的分析一下三个构造器的使用。 ArrayList()ArrayList无参的构造器,使用这个无参构造器会默认有一个长度为10的数组。 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; ArrayList(int)传入一个int值，这个值为ArrayList的初始容量。如果等于0则会默认使用EMPTY_ELEMENTDATA生成一个空的集合。如果输入为非负数的话会抛出一个IllegalArgumentException(非法参数)异常。 12345678910 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; ArrayList(Collection)这个构造函数是传入一个集合,toArray是将这个集合转化为一个实际的数组，下面的程序就是和传入int类型是差不多的，判断数组长度是否为0，如果等于0则会默认使用EMPTY_ELEMENTDATA生成一个空数组。在不为空的时候，将Collection的值copy到ArrayList。 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 方法trimToSize()该方法主要是用于将ArrayList实际容量调整为列表当前大小。这里它实用了一个三目运算? :。 modCount这个变量在AbstractList这个类里面,其中定义int这个变量使用了transient。 protected transient int modCount = 0; transient 当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中。 三目运算和if else的区别，三目运算是会有一个返回值的，if else没有返回值。如果非要写成if else应该也可以。 12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; ensureCapacity()如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。 DEFAULT_CAPACITY=10是一个常量1234567891011public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It&apos;s already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; indexOf()返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。更确切地讲，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最低索引 i ，如果不存在此类索引，则返回 -1。 123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; contains()如果此列表中包含指定的元素，则返回 true。更确切地讲，当且仅当此列表包含至少一个满足 (o==null ? e==null : o.equals(e)) 的元素 e 时，则返回 true。 123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; lastIndexOf()lastIndexOf用于返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。这里if和else里面采用了两种不同的比较方法。if代码块里面是采用了==说明比较的是对象，而else的代码块采用的是equals比较。为什么这里采用两种比较方法呢？ 这里产生一个疑问？ null是对象还是值？ 正在技术论坛上提问 Keywords 50 character sequences, formed from ASCII letters, are reserved for use as keywords and cannot be used as identifiers (§3.8).Keyword: one of abstract continue for new switch assert default if package synchronized boolean do goto private this break double implements protected throw byte else import public throws case enum instanceof return transient catch extends int short try char final interface static void class finally long strictfp volatile const float native super while The keywords const and goto are reserved, even though they are not currently used. This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in programs.While true and false might appear to be keywords, they are technically Boolean literals (§3.10.3). Similarly, while null might appear to be a keyword, it is technically the null literal (§3.10.7). 在这个50个关键字中没有null，但是下面的一行字写了。 While true and false might appear to be keywords, they are technically Boolean literals (§3.10.3). Similarly, while null might appear to be a keyword, it is technically the null literal (§3.10.7). 虽然true和false可能看起来是关键字，但它们在技术上是布尔值（§3.10.3）。类似地，虽然null可能看起来是一个关键字，但在技术上是null值（§3.10.7）。 java的官方文档里写着true,false,null是一个值，也就是说java有50个关键字，3个特殊的值。竟然是值，为什么在比较的时候会报错？ 12345678public class Main &#123; public static void main(String[] args) &#123; String a = null; String b = null; System.out.println(a == b); System.out.println(a.equals(b)); &#125;&#125; 输出结果12345678910 trueException in thread "main" java.lang.NullPointerException at Main.Main.main(Main.java:14) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)Process finished with exit code 1 第二个方法抛出一个空指针异常。竟然是一个值，那么应该两种都会显示ture。 这样也就说明了为什么和null比较时要用==而不是equals。12345678910public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; clone()返回此 ArrayList 实例的浅表复制。（不复制这些元素本身。） 什么是浅表复制(shallow copy)对于shallow copy的翻译很多，有叫浅表复制，浅复制，影子复制，与它向对的是深度复制。浅表复制被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象 1234567891011121314151617 /** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; &#125; add(E)该方法是用于添加将指定元素添加到末尾，通过ensureCapacityInternal()这个方法来为ArrayList扩容，在为elementData的末尾添加指定元素。代码的注释也强调了，是增加modCount。 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; add(int,E)这个方法的一开始就调用了rangCheckForAdd()这个方法，这个私有方法主要是用来判断传入的索引，如果传入的数值大于最大值或者小于零会抛出一个越界异常。System.arraycopy()是用来复制数组的，将要添加位置之后的数组整体后移一位。 1234567891011121314public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; remove(Object)移除此列表中首次出现的指定元素（如果存在）。如果列表不包含此元素，则列表不做改动。更确切地讲，移除满足 (o==null ? get(i)==null : o.equals(get(i))) 的最低索引的元素（如果存在此类元素）。如果列表中包含指定的元素，则返回 true（或者等同于这种情况：如果列表由于调用而发生更改，则返回 true）。 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; clear()通过一个循环将ArrayList中的元素赋值为null，最后将size赋值为0，这样应该就会保证没有浪费内存。 123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; ListIterator()用于集合遍历，如果索引大于最大值或者小于0，抛出异常，否者使用ListItr()进行。 12345public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index); &#125; ListItr()这是一个私有的内部类，继承了Iterator这个接口， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; replaceAll()这个方法是用来替换所有的匹配项 传入的参数是UnaryOperator是在java 8引入的lambda表达式，具体如何使用以后再说。123456789101112public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; sort()12345678public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MD5加密]]></title>
      <url>%2F2016%2F10%2F27%2FMD5%E5%8A%A0%E5%AF%86%2F</url>
      <content type="text"><![CDATA[什么是MD5加密MD5加密即Message-Digest Algorithm5，历经了MD2，MD4发展，在1991年提出。 中文名：消息摘要算法第五版 英文名：Message-Digest Algorithm5 提出时间：1991年 基本原理MD5就是byte值和一个int的255进行与运算，得到一个int值，再将这个int值转化为十六进制的值，这样就完成了一个MD5加密。 特点只能从明文加密为密文，不能把密文在转化为明文。加密后是不可逆性。确保明文的加密性。 MD5加密代码通过MD5的密文进行加密。 示例代码12345678910111213141516171819202122232425262728import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Utils &#123; public static void main(String[] args) &#123; String passWord = "123456"; StringBuilder sb = new StringBuilder(); //获取数据摘要器 try &#123; MessageDigest messageDigest = MessageDigest.getInstance("MD5"); //将一个byte数组进行加密操作，返回的是一个加密的byte数组，二进制的哈西计算，md5加密的第一步 byte[] digest = messageDigest.digest(passWord.getBytes()); for (int i = 0; i &lt; digest.length; i++) &#123; int result = digest[i] &amp; 0xff; //将得到的int类型的值转化为16进制的值 String hexString = Integer.toHexString(result); if (hexString.length()&lt;2)&#123;//系统会自动把0省略，所以添加0 sb.append("0"); &#125; sb.append(hexString); &#125; System.out.println(sb.toString()); &#125; catch (NoSuchAlgorithmException e) &#123;//找不到加密方式异常 e.printStackTrace(); &#125; &#125;&#125; 输出结果为：e10adc3949ba59abbe56e057f20f883e 防破解上面的代码可以对123456进行加密，但是目前网上有好多破解网站，他们的破解原理就是将一些常见的MD5加密密文保存到数据库中，通过比对来达到所谓的破解。所以通过下面的方法进行加密会完全是网上 不规则加密(加盐)通过对十六进制变量后进行不规则操作加密,在13行代码后边加数，进行不规则加密。这样会的话几乎已经无法完成破解了。 12345678910111213141516171819202122232425import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Utils &#123; public static void main(String[] args) &#123; String passWord = "123456"; StringBuilder sb = new StringBuilder(); try &#123; MessageDigest messageDigest = MessageDigest.getInstance("MD5"); byte[] digest = messageDigest.digest(passWord.getBytes()); for (int i = 0; i &lt; digest.length; i++) &#123; int result = digest[i] &amp; 0xff; String hexString = Integer.toHexString(result)+1;//不规则加密，俗称加盐 if (hexString.length()&lt;2)&#123; sb.append("0"); &#125; sb.append(hexString); &#125; System.out.println("密码为 123456\n 加密后"); System.out.println(sb.toString()); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 加密结果e11a1dc1391491ba1591ab1be1561e01571f21f18813e1 银行系统MD5加密方式这种是银行等系统要求安全性非常高的系统，一般会对加密后的密文再次进行一次MD5加密，这样进行10-30次，达到一个无法破解的密文。 123456789101112131415161718192021222324252627282930import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Utils &#123; //银行 银行卡 6位数 将密码进行十到三十次MD5加密 public static void main(String[] args) &#123; String passWord = "123456"; StringBuilder sb = new StringBuilder(); try &#123; MessageDigest messageDigest = MessageDigest.getInstance("MD5"); for (int h = 0; h &lt; 10; h++) &#123; //进行多次循环加密 byte[] digest = messageDigest.digest(passWord.getBytes()); for (int i = 0; i &lt; digest.length; i++) &#123; int result = digest[i] &amp; 0xff; String hexString = Integer.toHexString(result)+1; if (hexString.length() &lt; 2) &#123; sb.append("0"); &#125; sb.append(hexString); &#125; passWord = sb.toString(); sb.delete(0, sb.length()); &#125; System.out.println(passWord); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 加密后结果：6912c1901801301e61951b01281ca1f21ca1dd1dc17e12a1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[StringBuilder源码分析]]></title>
      <url>%2F2016%2F10%2F25%2FStringBuilder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[#StringBuilder源码分析 作者wevanyoungxhui 概况一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。 签名123public final class StringBuilderextends AbstractStringBuilderimplements java.io.Serializable, CharSequence 可以看到StringBuilder继承了 Serializable：可以序列化的标志。 CharSequence接口：包含了charAt()、length() 、subSequence()、toString()这几个方法，String类也实现了这个接口。 抽象类AbstractStringBuilder，这个类封装了StringBuilder和StringBuffer大部分操作的实现 CharSequence接口这个接口是代表一个有序字符集合，使用该接口的方法一共有四个：CharBuffer、String、StringBuffer、StringBuilder。 ##AbstractStringBuilder类 变量及构造方法 123456char[] value;int count;AbstractStringBuilder() &#123;&#125;AbstractStringBuilder(int capacity) &#123; value = new char[capacity];&#125; AbstractStringBuilder内部用一个char[]数组保存字符串，可以在构造的时候指定初始容量方法。 ###append()方法123456789101112131415161718192021222324252627282930313233 public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; &#125;``` append()方法用于追加字符，如果str是null,则会调用appendNull()方法。这个方法其实是追加了'n'、'u'、'l'、'l'这几个字符。如果不是null，则首先扩容，然后调用String的getChars()方法将str追加到value末尾。最后返回对象本身，所以append()可以连续调用。***##Stringbuilder构造器### StringBuilder()这个构造器的作用是构造一个初始化不带参数的，初始化字节为`16`字节。### StringBuilder(int)构造一个其中不带字符的字符串生成器，初始容量由传入的 `int` 值指定。### StringBuilder(String)构造一个字符串生成器，并初始化为指定的字符串内容。该字符串生成器的初始容量为 16 加上字符串参数的长度。```javapublic StringBuilder(String str) &#123; super(str.length() + 16); append(str); &#125; 如果传入的字符串问 null 则会抛出空指针 NullPointerException 异常。示例代码 12345678public class StringBuilderApi &#123; public static void main(String[] args) &#123; String str=null; StringBuilder stringBuilder=new StringBuilder(str); System.out.println(stringBuilder); &#125;&#125; 输出结果 Exception in thread “main” java.lang.NullPointerException at java.lang.StringBuilder.(StringBuilder.java:112) at StringBuilderApi.main(StringBuilderApi.java:7) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147) StringBulider(CharSequence)构造一个字符串生成器，包含与指定的 CharSequence 相同的字符。该字符串生成器的初始容量为 16 加上 CharSequence 参数的长度。 append()方法该方法一共用13个重载函数,用于实现不同的数据类型。Object,String,StringBuffer,CharSequence,char[],boolen,int ,long,float,double 等,但是他们的作用是一直的。那就是将参数添加到字符串中。 12345678public StringBuilder append(String str) &#123;super.append(str);return this;&#125;public StringBuilder append(CharSequence s) &#123;super.append(s);return this;&#125; Stringbulider的appen()方法显然直接调用的父类AbstractStringBuilder中的该方法。 appendCodePoint()方法该方法是附加一个Uncode字符在字符串末尾。 12345678/** * @since 1.5 */ @Override public StringBuilder appendCodePoint(int codePoint) &#123; super.appendCodePoint(codePoint); return this; &#125; delete()方法该方法是删除所字符串中的字符，所传入的参数为其实点和结束点。直接使用父类(AbstractStringBuilder)的方法 12345678/** * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125; */ @Override public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this; &#125; toString()方法toString()方法返回了一个新的String对象，与原来的对象不共享内存。 1234public String toString() &#123;// Create a copy, don't share the array return new String(value, 0, count);&#125; replace()方法replace 方法仍旧继承了父类的 replace 方法,是替换字符1234public StringBuilder replace(int start, int end, String str) &#123; super.replace(start, end, str); return this; &#125; insert()方法该方法是插入字符串。该方法重载了12个方法。 总结该类所有的方法都是通过父类( AbstractStringBuilder )来实现。该方法与String和StringBuffer的区别在于，String是不可修改的，StringBuffer和StringBuilder是可以修改的，但是StringBuffer是线程安全的，StringBuilder是线程不安全的，但是在效率上， StringBuffer 因为对方法做了同步，所以一般是低于 StringBuilder的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[String源码剖析]]></title>
      <url>%2F2016%2F09%2F11%2FString%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%2F</url>
      <content type="text"><![CDATA[String是java程序中出现比较多的对象，分析一下String首先String是由final修饰的。因此String不可变，无法继承。 将方法或类声明为final主要目的是：确保它们不会再子类中改变语义。String类是final类，这意味着不允许任何人定义String的子类。换言之，如果有一个String的引用，它引用的一定是一个String对象，而不可能是其他类的对象。——《Java核心技术 卷I》作者：R eversal链接：https://www.zhihu.com/question/31345592/answer/51639967来源：知乎著作权归作者所有，转载请联系作者获得授权。 String不可变性及其原因String的不可变性什么叫String的不可变性呢？让我们来看一个例子。 String s=“abcd“；上面的语句定义了一个字符串变量s，该变量指向字符串“abcd”，当初始化变量s时，会在堆中为s非配内容空间，当将字符串变量，赋值给另一个字符串变量时，例如：String s2=s；此时，s2和s是相同的字符串对象，它们指向堆中的同一个内存空间。当一个字符串连接其他字符时，他就指向了新的字符串对象，例如，s=s.concat(“ef“）， 此时，s=”abcdef”;它在内存中又指向了一个新的储存空间，存放字符串”abcdef”。当一个字符串在堆中被分配内容时，它就是不可变的，任何String的方法都无法改变字符串本身，但它可以返回一个新的字符串对象。由于String是不可变的，所以他们的空间可以共享。例如String str = “abc”;就和JAVA char data[] = {‘a’, ‘b’, ‘c’}; String str = new String(data); 是等价的，它们共享一个存储空间。如果需要可以修改的字符串对象，可以使用StringBuffer和StringBuilder，StringBuffer是线程安全的，由于StringBuilder不需要进行同步操作，StringBuilder是比较快速的。 String不可变性的原因 源码中String的本质是一个final类型的char数组，既然是final类型，那个该数组引用value就不允许再指向其他对象了，因此只从类的设计角度讲：如果jdk源码中并没有提供对value本身的修改，那么理论上来讲String是不可变的 字符串池（String pool）的需求 在Java中，当初始化一个字符串变量时，如果字符串已经存在，就不会创建一个新的字符串变量，而是返回存在字符串的引用。 例如： String string1=”abcd”; String string2=”abcd”; 这两行代码在堆中只会创建一个字符串对象。如果字符串是可变的，改变另一个字符串变量，就会使另一个字符串变量指向错误的值。 缓存字符串hashcode码的需要 字符串的hashcode是经常被使用的，字符串的不变性确保了hashcode的值一直是一样的，在需要hashcode时，就不需要每次都计算，这样会很高效。 出于安全性考虑 字符串经常作为网络连接、数据库连接等参数，不可变就可以保证连接的安全性。 签名（signature） 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence String使用了 标记接口 java.io.Serializable 标记接口 Comparable 标记接口 CharSequenc Compareable接口123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 此接口强行对实现它的每个类的对象进行整体排序。此排序被称为该类的自然排序，类的 compareTo 方法被称为它的自然比较方法 。 CharSequence接口CharSequence的所有成员变量和方法。 成员变量 private final char value[];//这是用于存储String字符的数组 private final int offset;//这是value数组的第一个有效的字符的index private final int count;//这是String中的字符个数 private int hash; // 存储String的hashcode，默认是0 private static final long serialVersionUID = -6849794470754667710L;//在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常 源码剖析构造器String类的构造器有十六个，除了提供了一个无参构造函数之外，还有十五个带参构造器。 String()123public String() &#123; this.value = "".value; &#125; 初始化一个新创建的 String 对象，使其表示一个空字符序列。注意，由于 String 是不可变的，所以无需使用此构造方法 String(String)1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 初始化一个新创建的 String对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。由于 String 是不可变的，所以无需使用此构造方法，除非需要 original 的显式副本。 String(char)123public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length); &#125; 分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。该字符数组的内容已被复制；后续对字符数组的修改不会影响新创建的字符串。 String(char,int,int)12345678910111213141516171819public String(char value[], int offset, int count) &#123; public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = "".value; return; &#125; &#125; if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count); &#125; 作用为分配一个新的value，将传入的char数组进行一次复制，offset是开始索引位置，count表示数组长度。 String(int,int,int)1234567891011121314151617181920212223242526272829303132333435363738394041424344public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= codePoints.length) &#123; this.value = "".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++); &#125; this.value = v; &#125; 方法checkBounds()方法12345678private static void checkBounds(byte[] bytes, int offset, int length) &#123; if (length &lt; 0) throw new StringIndexOutOfBoundsException(length); if (offset &lt; 0) throw new StringIndexOutOfBoundsException(offset); if (offset &gt; bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length); &#125; 这是一个私有的静态方法用于检查边界的方法。 length()方法获得长度的方法 123public int length() &#123; return value.length; &#125; isEmpty()方法检查字符串长度是否是0，当长度为0返回true，否则返回false。 123public boolean isEmpty() &#123; return value.length == 0; &#125; charAt()方法该方法返回的值为char数组中的其中一个。 123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index]; &#125; codePointAt()方法用于返回指定索引处的字符，与codePointBefore方法类似，codePointBefore返回的的是索引之前的值 codePointAt 123456public int codePointAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointAtImpl(value, index, value.length); &#125; codePointBefore 1234567public int codePointBefore(int index) &#123; int i = index - 1; if ((i &lt; 0) || (i &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointBeforeImpl(value, index, 0); &#125; equals()方法首先equals返回的为一个boolean值。instanceof是一个java的二元操作符，作用是检查左面是否为右面的实例化。返回值是boolean类型。该方法是将一个传入对象进行一次复制，将复制对象的字符数组与原对象的字符数组进行比较。这样就确保equals比较的是内容。这样就和==有了区分 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; compareTo()方法按字典顺序比较两个字符串,如果相通返回0，如果不同返回他们之间的差值。同样是通过字符数组进行比较。 123456789101112131415161718public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2; &#125; ### compare()方法 12345678910111213141516171819202122232425262728293031private static class CaseInsensitiveComparator implements Comparator&lt;String&gt;, java.io.Serializable &#123; // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) &#123; int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i &lt; min; i++) &#123; char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) &#123; c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) &#123; c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) &#123; // No overflow because of numeric promotion return c1 - c2; &#125; &#125; &#125; &#125; return n1 - n2; &#125; /** Replaces the de-serialized object. */ private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125; &#125; startsWith()方法检查前缀是否匹配。 1234567891011121314151617public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1&gt;&gt;&gt;1. if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true; &#125; hashCode()方法返回String的hashCode，hashCode的计算方法是s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 1234567891011public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; indexOf方法indexOf一共有六个构造方法。返回字符出现在字符串中第一次的位置。 1234567891011121314151617181920212223public int indexOf(int ch, int fromIndex) &#123; final int max = value.length; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; else if (fromIndex &gt;= max) &#123; // Note: fromIndex might be near -1&gt;&gt;&gt;1. return -1; &#125; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return indexOfSupplementary(ch, fromIndex); &#125; &#125; substring()方法截取代码中的片段，值得注意的是在最后的返回值中它会new一个新String类。 1234567891011121314public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); &#125; concat()方法该方法主要用于连接字符串，Api文档中的例子 “cares”.concat(“s”) returns “caress” 从功能上看concat和+是类似的。但是他们之间使用区别的。concat只能连接字符串，如果要连接其他类型要转化为String。+可以连接非字符串。如果长度为0返回原来的数组，否则就new一个数组。 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true); &#125; ### replace()方法 replace用于替换String中的字符。先用if来判断，来减少不必要的循环。 1234567891011121314151617181920212223242526public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j]; &#125; while (i &lt; len) &#123; char c = val[i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(buf, true); &#125; &#125; return this; &#125; ### split ### replaceAll join()方法这个是jdk1.8的新方法，让我们分析一下。join的作用：通过一个字符或字符串来连接其他字符注释文档的例子： String message = String.join(“-“, “Java”, “is”, “cool”); // message returned is: “Java-is-cool” 官方文档中的注释提示 Note that if an element is null, then {@code “null”} is added. 12345678910public static String join(CharSequence delimiter, CharSequence... elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString(); &#125; ### toLowerCase()方法 该方法是将传入的字符串转化为一个小写的字符串。这里有一个scan，这个scan是一个标签，用于跳出循环。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public String toLowerCase(Locale locale) &#123; if (locale == null) &#123; throw new NullPointerException(); &#125; int firstUpper; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: &#123; for (firstUpper = 0 ; firstUpper &lt; len; ) &#123; char c = value[firstUpper]; if ((c &gt;= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123; int supplChar = codePointAt(firstUpper); if (supplChar != Character.toLowerCase(supplChar)) &#123; break scan; &#125; firstUpper += Character.charCount(supplChar); &#125; else &#123; if (c != Character.toLowerCase(c)) &#123; break scan; &#125; firstUpper++; &#125; &#125; return this; &#125; char[] result = new char[len]; int resultOffset = 0; /* result may grow, so i+resultOffset * is the write location in result */ /* Just copy the first few lowerCase characters. */ System.arraycopy(value, 0, result, 0, firstUpper); String lang = locale.getLanguage(); boolean localeDependent = (lang == "tr" || lang == "az" || lang == "lt"); char[] lowerCharArray; int lowerChar; int srcChar; int srcCount; for (int i = firstUpper; i &lt; len; i += srcCount) &#123; srcChar = (int)value[i]; if ((char)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123; srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); &#125; else &#123; srcCount = 1; &#125; if (localeDependent || srcChar == '\u03A3' || // GREEK CAPITAL LETTER SIGMA srcChar == '\u0130') &#123; // LATIN CAPITAL LETTER I WITH DOT ABOVE lowerChar = ConditionalSpecialCasing.toLowerCaseEx(this, i, locale); &#125; else &#123; lowerChar = Character.toLowerCase(srcChar); &#125; if ((lowerChar == Character.ERROR) || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123; if (lowerChar == Character.ERROR) &#123; lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale); &#125; else if (srcCount == 2) &#123; resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount; continue; &#125; else &#123; lowerCharArray = Character.toChars(lowerChar); &#125; /* Grow result if needed */ int mapLen = lowerCharArray.length; if (mapLen &gt; srcCount) &#123; char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; &#125; for (int x = 0; x &lt; mapLen; ++x) &#123; result[i + resultOffset + x] = lowerCharArray[x]; &#125; resultOffset += (mapLen - srcCount); &#125; else &#123; result[i + resultOffset] = (char)lowerChar; &#125; &#125; return new String(result, 0, len + resultOffset);&#125; trim()方法trim方法是去除前或后无效空格。通过两个循环，一个从前开始，一个从后开始来寻找空格。 12345678910111213public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this; &#125; toCharArray()方法该方法是用于将字符串复制为一个新的字符数组。 123456public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; &#125; intern方法native关键字是一个用于修饰原生态方法。作用是实现其他接口的语言如(c/c++)。 1public native String intern(); 总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub for Windows使用教程(四)]]></title>
      <url>%2F2016%2F08%2F28%2FGitHub-for-Windows%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Github for windows使用教程(四)前言在上述的几个教程里讲解了一些Github的基础使用，现在开始讲解一些使用技巧。 查找内容在github页面上是没有搜索的按钮，如何搜索呢。在网页上按 T就会出现。这样我们就能很方便的查找到我们需要的代码了。 评论小表情常常在版本描述或者pull request时我们需要对伙伴的代码进行一下评论与说明，光是文字有点很死板，其实github给我有emoji，如何使用呢？其实很简单，只需要冒号就可以 ：，这样我们就可以看到emoji表情，当然默认会显示五个常用的，你也可以继续敲下emoji的名字，出现更多（这里有所有的表情）。 忽略不想上传的文件有些在github中的文件我们是不想上传的，我们如何过滤掉它们呢？在github中对不想上传的文件点击右键。就会出现下面选项。Ignore file忽略这个文件Ignore all.txt files 忽略所有的以.txt结尾的文件这样就可以过滤掉你不想上传的文件 搜索项目如何高效的搜索一个你想要的库呢？我们常常评判一个项目的标准有star数目，fork数目和跟新时间。通过搜索命令 stars stars:&gt;1000 表示star数目大于1000。 fork fork:&gt;1000 表示fork数目大于1000。 语言搜索 java，html等等 综合一下就是，比如你要查找一个stars大于1000的，fork大于200的java代码。 stars:&gt;1000 fork:&gt;200 java 就是这样。 查看项目中的语言类型一个项目中，可能使用了多种语言，我们如何一下子就能看到一个项目使用了什么语言？其实很简单，Github已经为我们统计好了。 也行你注意过，但是没有发现它有什么用。点击下面的彩条 github已经为我们统计好这个项目所有的语言及其比例。 一些常见的代码表示颜色 总结码字不易，终于写完了，如果觉得对你有帮助，我的目的就达到了。谢谢如有错误，还望指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git基本操作]]></title>
      <url>%2F2016%2F08%2F13%2FGit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[下载安装Git客户端 git下载 安装教程装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。 创建本地仓库$ git init 添加 add把文件添加到仓库：$ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 把文件提交到仓库：$ git commit -m &quot;add readme&quot; git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 同步到Github上传到github例如我们给一个叫Test的仓库同步 $ git remote add origin git@github.com:youngxhui/Test.git 现在可以push到你的仓库了 $ git push -u origin master 第一次推送时，我们要添加-u 之后我们可以这条命令 $ git push origin master 下载到github从github上下载到本地 $ git clone git@github.com:youngxhui/nuc_JavaLab.git 分支的操作分支的创建创建分支 $ git checkout -b dev -b 参数表示创建并切换 查看分支用git branch命令查看当前分支： $ git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 我们就可以在dev分支上正常提交 $ git add readme.txt $ git commit -m &quot;branch test&quot; 切换分支切换回master分支： $ git checkout master 合并分支把dev分支合并到master $ git merge dev 删除分支$ git branch -d dev]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2016%2F08%2F09%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[正则表达式什么是正则表达式 正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。 正则表达式可以对字符串进行查找，提取，分割，替换等操作。 创建正则表达式正则表达式就是一个用于匹配字符串的模板，可以匹配一串字符串，所以创造正则表达式就是创建一个特殊字符串。正则表达式所支持的合法字符 字符 解释 x 字符x（x可代表任何合法的字符） \0mnn 八进制数用\0mnn \xhh 十六进制值0xhh所表示的字符 \xhhh 十六进制值0xhhhh所表示的Unicode字符 \t 制表符（’\u0009’） \n 新行（换行）符(‘\u000A’) \r 回车符（’\u000D’） \f 换页符（’\u000C’） \a 报警（bell）符（’\u0007’） \e Escape符（’\u001B’） \cx x对应的控制符。例如，\cM 匹配ctrl-M。x值必须为A-Z或者a~z之一 正则表达式中的特殊字符 特殊字符 说明 $ 匹配一行的结尾。要匹配\$字符本身 ^ 匹配一行的开头。要匹配^字符本身 () 标记子表达式的开始和结束位置。要用匹配这些字符。 [] 用于确定中括号表达式的开始和结束位置。 {} 用于标记前面子表达式的出现频率 * 指定前面子表达式出现零次或多次 + 指定前面子表达式可以出现一次或多次 ? 指定前面子表达式可以出现零次或一次 . 匹配除换行符\n之外的任何单字符 \ 用于转义下一个字符，或指定八进制，十六进制字符。 \ 指定两项之间任选一项]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[底部导航按钮]]></title>
      <url>%2F2016%2F08%2F05%2F%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%8C%89%E9%92%AE%2F</url>
      <content type="text"><![CDATA[关于底部按钮的实现关于底部导航按钮网上实现底部按钮的方法有很多，在这里RadioGroup+ViewPager+fragmnt实现的。 底部导航支持底部点击和滑动。 上图 布局代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;RadioGroup android:id="@+id/rg_tab_bar" android:layout_width="match_parent" android:layout_height="56dp" android:layout_alignParentBottom="true" android:background="@color/bg_white" android:elevation="5dp" android:orientation="horizontal"&gt; &lt;RadioButton android:id="@+id/rb_channel" style="@style/tab_menu_item" android:drawableTop="@drawable/tab_menu_doc" android:text="@string/tab_menu_doc" /&gt; &lt;RadioButton android:id="@+id/rb_message" style="@style/tab_menu_item" android:drawableTop="@drawable/tab_menu_camera" android:text="@string/tab_menu_camera" /&gt; &lt;RadioButton android:id="@+id/rb_better" style="@style/tab_menu_item" android:drawableTop="@drawable/tab_menu_user" android:text="@string/tab_menu_user" /&gt; &lt;/RadioGroup&gt; &lt;View android:id="@+id/div_tab_bar" android:layout_width="match_parent" android:layout_height="2px" android:layout_above="@id/rg_tab_bar" android:background="@color/div_white" /&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/vpager" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_above="@id/div_tab_bar" /&gt;&lt;/RelativeLayout&gt; activity代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MainActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener, ViewPager.OnPageChangeListener &#123; //UI Objects private RadioGroup rg_tab_bar; private RadioButton rb_channel; private RadioButton rb_message; private RadioButton rb_better; private ViewPager vpager; private MyFragmentPagerAdapter mAdapter; //几个代表页面的常量 public static final int PAGE_ONE = 0; public static final int PAGE_TWO = 1; public static final int PAGE_THREE = 2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mAdapter = new MyFragmentPagerAdapter(getSupportFragmentManager()); bindViews(); rb_channel.setChecked(true); &#125; private void bindViews() &#123; rg_tab_bar = (RadioGroup) findViewById(R.id.rg_tab_bar); rb_channel = (RadioButton) findViewById(R.id.rb_channel); rb_message = (RadioButton) findViewById(R.id.rb_message); rb_better = (RadioButton) findViewById(R.id.rb_better); rg_tab_bar.setOnCheckedChangeListener(this); vpager = (ViewPager) findViewById(R.id.vpager); vpager.setAdapter(mAdapter); vpager.setCurrentItem(0); vpager.addOnPageChangeListener(this); &#125; @Override public void onCheckedChanged(RadioGroup group, int checkedId) &#123; switch (checkedId) &#123; case R.id.rb_channel: vpager.setCurrentItem(PAGE_ONE); break; case R.id.rb_message: vpager.setCurrentItem(PAGE_TWO); break; case R.id.rb_better: vpager.setCurrentItem(PAGE_THREE); break; &#125; &#125; //重写ViewPager页面切换的处理方法 @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; //state的状态有三个，0表示什么都没做，1正在滑动，2滑动完毕 if (state == 2) &#123; switch (vpager.getCurrentItem()) &#123; case PAGE_ONE: rb_channel.setChecked(true); break; case PAGE_TWO: rb_message.setChecked(true); break; case PAGE_THREE: rb_better.setChecked(true); break; &#125; &#125; &#125;&#125; FragmentPagerAdapter数据适配器 MyFragmentPagerAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MyFragmentPagerAdapter extends FragmentPagerAdapter &#123; private final int PAGER_COUNT = 3; private DocFRAG docFRAG = null; private CameraFRAG cameraFRAG = null; private UserFRAG userFRAG = null; public MyFragmentPagerAdapter(FragmentManager fm) &#123; super(fm); docFRAG = new DocFRAG(); cameraFRAG = new CameraFRAG(); userFRAG = new UserFRAG(); &#125; @Override public int getCount() &#123; return PAGER_COUNT; &#125; @Override public Object instantiateItem(ViewGroup vg, int position) &#123; return super.instantiateItem(vg, position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; System.out.println("position Destory" + position); super.destroyItem(container, position, object); &#125; @Override public Fragment getItem(int position) &#123; Fragment fragment = null; switch (position) &#123; case MainActivity.PAGE_ONE: fragment = docFRAG; break; case MainActivity.PAGE_TWO: fragment = cameraFRAG; break; case MainActivity.PAGE_THREE: fragment = userFRAG; break; &#125; return fragment; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FlaotActionButton详解]]></title>
      <url>%2F2016%2F08%2F05%2FFlaotActionButton%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[今天把Android的学习的一些东西记录一下，方便日后使用。 FlaotActionButton详解FlaotActionButton是android的一个很好用的控件。在看了很多源码后逐步掌握一些知识了。 导入依赖项首先要在build.gradle中导入依赖项 12345678dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:24.1.1' compile 'com.android.support:design:24.1.1' compile 'com.getbase:floatingactionbutton:1.10.1'&#125; GitHub地址 代码 1234567891011121314151617181920212223242526272829303132333435&lt;com.getbase.floatingactionbutton.FloatingActionsMenu android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:layout_alignParentEnd="true" android:layout_marginBottom="31dp" android:layout_marginEnd="32dp" app:fab_addButtonSize="normal" app:fab_labelStyle="@style/menu_labels_style"&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:id="@+id/fab_carm" android:layout_width="wrap_content" android:layout_height="wrap_content" app:backgroundTint="@color/colorPrimary" app:fabSize="mini" app:fab_title="拍照" fab:fab_icon="@drawable/ic_add_a_photo_black_24dp" /&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:id="@+id/fab_etid" android:layout_width="wrap_content" android:layout_height="wrap_content" app:fabSize="mini" app:fab_title="录入" fab:fab_icon="@drawable/ic_border_color_black_24dp" /&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:id="@+id/fab_pic" android:layout_width="wrap_content" android:layout_height="wrap_content" app:fabSize="mini" app:fab_title="识别图片" fab:fab_icon="@drawable/ic_photo_black_24dp" /&gt; &lt;/com.getbase.floatingactionbutton.FloatingActionsMenu&gt; 要适配menu_labels_style才可以使用FloatingActionsMenu1234&lt;style name="menu_labels_style"&gt; &lt;item name="android:background"&gt;@drawable/fab_label_background&lt;/item&gt; &lt;item name="android:textColor"&gt;@color/white&lt;/item&gt; &lt;/style&gt; 适配fab_label_background &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@color/black_semi_transparent&quot;/&gt; &lt;padding android:left=&quot;16dp&quot; android:top=&quot;4dp&quot; android:right=&quot;16dp&quot; android:bottom=&quot;4dp&quot;/&gt; &lt;corners android:radius=&quot;2dp&quot;/&gt; &lt;/shape&gt; 解析FloatActionButton代码FloatActionButton中通过app:fabSize来确定大小normal，mini，auto。通过app:fab_title设置文字。fab:fab_icon设置图标。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidManifest.xml详细介绍]]></title>
      <url>%2F2016%2F07%2F21%2FAndroidManifest-xml%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[#AndroidManifest.xml详细介绍 基于Android Studio 2.1目录 一、关于AndroidManifest.xmlAndroidManifest.xml是每个android程序中必须的文件。是一个清单文件。它位项目的manifes目录，它是整个Android应用的描述文件。AndroidManifast.xml清单文件说明了该应用的名称，所使用的图标等。 AndroidManifest.xml清单文件通常包含以下的信息： 1.应用程序的包名。 应用所含的组件，如Activity，Service，BroadcastReceiver和ContentProvider等。 应用程序兼容的最低版本。 应用要使用的权限。5.其他程序访问该应用需要的权限。 二、AndroidManifest.xml结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;manifest&gt; &lt;application&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;action/&gt; &lt;category/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity-alias&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/activity-alias&gt; &lt;service&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/service&gt; &lt;receiver&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/receiver&gt; &lt;provider&gt; &lt;grant-uri-permission/&gt; &lt;meta-data/&gt; &lt;/provider&gt; &lt;uses-library/&gt; &lt;/application&gt; &lt;uses-permission/&gt; &lt;permission/&gt; &lt;permission-tree/&gt; &lt;permission-group/&gt; &lt;instrumentation/&gt; &lt;uses-sdk/&gt; &lt;uses-configuration/&gt; &lt;uses-feature/&gt; &lt;supports-screens/&gt;&lt;/manifest&gt; 三、各个节点的详细介绍 上面就是整个androidManifest.xml的结构，下面以外向内开始阐述～～ 1、第一层:Manifest属性12345678&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.woody.test" android:sharedUserId="string" android:sharedUserLabel="string resource" android:versionCode="integer" android:versionName="string" android:installLocation=["auto" | "internalOnly" | "preferExternal"] &gt;&lt;/manifest&gt; xmlns:android 定义android命名空间，一般为http://schemas.android.com/apk/res/android，这样使得Android中各种标准属性能在文件中使用，提供了大部分元素中的数据。 package 指定本应用内java主程序包的包名，它也是一个应用进程的默认名称 sharedUserId 表明数据权限，因为默认情况下，Android给每个APK分配一个唯一的UserID，所以是默认禁止不同APK访问共享数据的。若要共享数据，第一可以采用Share Preference方法，第二种就可以采用sharedUserId了，将不同APK的sharedUserId都设为一样，则这些APK之间就可以互相共享数据了。详见：http://wallage.blog.163.com/blog/static/17389624201011010539408/ sharedUserLabel 一个共享的用户名，它只有在设置了sharedUserId属性的前提下才会有意义 versionCode 是给设备程序识别版本(升级)用的必须是一个interger值代表app更新过多少次，比如第一版一般为1，之后若要更新版本就设置为2，3等等。 versionName 这个名称是给用户看的，你可以将你的APP版本号设置为1.1版，后续更新版本设置为1.2、2.0版本等等。 installLocation 安装参数，是Android2.2中的一个新特性，installLocation有三个值可以选择：internalOnly、auto、preferExternal 选择preferExternal,系统会优先考虑将APK安装到SD卡上(当然最终用户可以选择为内部ROM存储上，如果SD存储已满，也会安装到内部存储上) 选择auto，系统将会根据存储空间自己去适应 选择internalOnly是指必须安装到内部才能运行 注：需要进行后台类监控的APP最好安装在内部，而一些较大的游戏APP最好安装在SD卡上。现默认为安装在内部，如果把APP安装在SD卡上，首先得设置你的level为8，并且要配置android:installLocation这个参数的属性为preferExternal 2、第二层:Application属性一个AndroidManifest.xml中必须含有一个Application标签，这个标签声明了每一个应用程序的组件及其属性(如icon,label,permission等) 12345678910111213141516171819&lt;application android:allowClearUserData=["true" | "false"] android:allowTaskReparenting=["true" | "false"] android:backupAgent="string" android:debuggable=["true" | "false"] android:description="string resource" android:enabled=["true" | "false"] android:hasCode=["true" | "false"] android:icon="drawable resource" android:killAfterRestore=["true" | "false"] android:label="string resource" android:manageSpaceActivity="string" android:name="string" android:permission="string" android:persistent=["true" | "false"] android:process="string" android:restoreAnyVersion=["true" | "false"] android:taskAffinity="string" android:theme="resource or theme" &gt;&lt;/application&gt; android:allowClearUserData(‘true’ or ‘false’) 用户是否能选择自行清除数据，默认为true，程序管理器包含一个选择允许用户清除数据。当为true时，用户可自己清理用户数据，反之亦然 android:allowTaskReparenting(‘true’ or ‘false’) 是否允许activity更换从属的任务，比如从短信息任务切换到浏览器任务 android:backupAgent 这也是Android2.2中的一个新特性，设置该APP的备份，属性值应该是一个完整的类名，如com.project.TestCase，此属性并没有默认值，并且类名必须得指定(就是个备份工具，将数据备份到云端的操作) android:debuggable 这个从字面上就可以看出是什么作用的，当设置为true时，表明该APP在手机上可以被调试。默认为false,在false的情况下调试该APP，就会报以下错误： Device XXX requires that applications explicitely declare themselves as debuggable in their manifest. Application XXX does not have the attribute ‘debuggable’ set to TRUE in its manifest and cannot be debugged. android:description/android:label 此两个属性都是为许可提供的，均为字符串资源，当用户去看许可列表(android:label)或者某个许可的详细信息(android:description)时，这些字符串资源就可以显示给用户。label应当尽量简短，之需要告知用户该许可是在保护什么功能就行。而description可以用于具体描述获取该许可的程序可以做哪些事情，实际上让用户可以知道如果他们同意程序获取该权限的话，该程序可以做什么。我们通常用两句话来描述许可，第一句描述该许可，第二句警告用户如果批准该权限会可能有什么不好的事情发生 android:enabled Android系统是否能够实例化该应用程序的组件，如果为true，每个组件的enabled属性决定那个组件是否可以被 enabled。如果为false，它覆盖组件指定的值；所有组件都是disabled。 android:hasCode(‘true’ or ‘false’) 表示此APP是否包含任何的代码，默认为true，若为false，则系统在运行组件时，不会去尝试加载任何的APP代码 一个应用程序自身不会含有任何的代码，除非内置组件类，比如Activity类，此类使用了AliasActivity类，当然这是个罕见的现象 (在Android2.3可以用标准C来开发应用程序，可在androidManifest.xml中将此属性设置为false,因为这个APP本身已经不含有任何的JAVA代码了) android:icon 整个APP的图标，图片一般都放在drawable文件夹下。 android:killAfterRestore 在执行全系统的恢复操作时，配置恢复后相关的应用程序是否要被终止。 单个包的恢复操作不会导致程序被关闭。 全系统的恢复操作一般只会发生一次，即第一次配置手机时。 第三方应用程序通常不需要用到本属性。默认值是“true”，表示全系统恢复过程中，应用程序在处理完数据后将被关闭。 android:manageSpaceActivity 指定某个 Activity 子类的完全限定名称，系统可以启动此 Activity 来让用户管理应用程序占用的内存空间。 这个 Activity 必须已用activity > ```元素进行了声明。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869* android:name为应用程序所实现的Application子类的全名。当应用程序进程开始时，该类在所有应用程序组件之前被实例化。若该类(比方androidMain类)是在声明的package下，则可以直接声明android:name=&quot;androidMain&quot;,但此类是在package下面的子包的话，就必须声明为全路径或android:name=&quot;package名称.子包名成.androidMain&quot;* android:permission设置许可名，这个属性若在```&lt;application&gt;```上定义的话，是一个给应用程序的所有组件设置许可的便捷方式，当然它是被各组件设置的许可名所覆盖的* android:presistent该应用程序是否应该在任何时候都保持运行状态,默认为false。因为应用程序通常不应该设置本标识，持续模式仅仅应该设置给某些系统应用程序才是有意义的。* android:process应用程序运行的进程名，它的默认值为```&lt;manifest&gt;```元素里设置的包名，当然每个组件都可以通过设置该属性来覆盖默认值。如果你想两个应用程序共用一个进程的话，你可以设置他们的android:process相同，但前提条件是他们共享一个用户ID及被赋予了相同证书的时候* android:restoreAnyVersion同样也是android2.2的一个新特性，用来表明应用是否准备尝试恢复所有的备份，甚至该备份是比当前设备上更要新的版本，默认是false* android:taskAffinity拥有相同的affinity的Activity理论上属于相同的Task，应用程序默认的affinity的名字是&lt;manifest&gt;元素中设定的package名* android:theme是一个资源的风格，它定义了一个默认的主题风格给所有的activity,当然也可以在自己的theme里面去设置它，有点类似style。### 3、第三层:Activity属性```xml &lt;activity android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;] android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;] android:configChanges=[&quot;mcc&quot;, &quot;mnc&quot;, &quot;locale&quot;, &quot;touchscreen&quot;, &quot;keyboard&quot;, &quot;keyboardHidden&quot;, &quot;navigation&quot;, &quot;orientation&quot;, &quot;screenLayout&quot;, &quot;fontScale&quot;, &quot;uiMode&quot;] android:enabled=[&quot;true&quot; | &quot;false&quot;] android:excludeFromRecents=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:launchMode=[&quot;multiple&quot; | &quot;singleTop&quot; | &quot;singleTask&quot; | &quot;singleInstance&quot;] android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:noHistory=[&quot;true&quot; | &quot;false&quot;] android:permission=&quot;string&quot; android:process=&quot;string&quot; android:screenOrientation=[&quot;unspecified&quot; | &quot;user&quot; | &quot;behind&quot; | &quot;landscape&quot; | &quot;portrait&quot; | &quot;sensor&quot; | &quot;nosensor&quot;] android:stateNotNeeded=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:theme=&quot;resource or theme&quot; android:windowSoftInputMode=[&quot;stateUnspecified&quot;, &quot;stateUnchanged&quot;, &quot;stateHidden&quot;, &quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;, &quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;, &quot;adjustResize&quot;, &quot;adjustPan&quot;] &gt; &lt;/activity&gt; android:alwaysRetainTaskState 是否保留状态不变， 比如切换回home, 再从新打开，activity处于最后的状态。比如一个浏览器拥有很多状态(当打开了多个TAB的时候)，用户并不希望丢失这些状态时，此时可将此属性设置为true android:clearTaskOnLaunch比如 P 是 activity, Q 是被P 触发的 activity, 然后返回Home, 重新启动 P，是否显示 Q android:configChanges 当配置list发生修改时， 是否调用 onConfigurationChanged() 方法 比如 “locale|navigation|orientation”.这个我用过,主要用来看手机方向改变的. android手机在旋转后,layout会重新布局, 如何做到呢?正常情况下. 如果手机旋转了.当前Activity后杀掉,然后根据方向重新加载这个Activity. 就会从onCreate开始重新加载.如果你设置了 这个选项, 当手机旋转后,当前Activity之后调用onConfigurationChanged() 方法. 而不跑onCreate方法等. android:excludeFromRecents 是否可被显示在最近打开的activity列表里，默认是false android:finishOnTaskLaunch 当用户重新启动这个任务的时候，是否关闭已打开的activity，默认是false 如果这个属性和allowTaskReparenting都是true,这个属性就是王牌。Activity的亲和力将被忽略。该Activity已经被摧毁并非re-parented android:launchMode(Activity加载模式) 在多Activity开发中，有可能是自己应用之间的Activity跳转，或者夹带其他应用的可复用Activity。可能会希望跳转到原来某个Activity实例，而不是产生大量重复的Activity。这需要为Activity配置特定的加载模式，而不是使用默认的加载模式 Activity有四种加载模式： standard、singleTop、singleTask、singleInstance(其中前两个是一组、后两个是一组)，默认为standard standard：就是intent将发送给新的实例，所以每次跳转都会生成新的activity。 singleTop：也是发送新的实例，但不同standard的一点是，在请求的Activity正好位于栈顶时(配置成singleTop的Activity)，不会构造新的实例 singleTask：和后面的singleInstance都只创建一个实例，当intent到来，需要创建设置为singleTask的Activity的时候，系统会检查栈里面是否已经有该Activity的实例。如果有直接将intent发送给它。 singleInstance：首先说明一下task这个概念，Task可以认为是一个栈，可放入多个Activity。比如启动一个应用，那么Android就创建了一个Task，然后启动这个应用的入口Activity，那在它的界面上调用其他的Activity也只是在这个task里面。那如果在多个task中共享一个Activity的话怎么办呢。举个例来说，如果开启一个导游服务类的应用程序，里面有个Activity是开启GOOGLE地图的，当按下home键退回到主菜单又启动GOOGLE地图的应用时，显示的就是刚才的地图，实际上是同一个Activity，实际上这就引入了singleInstance。singleInstance模式就是将该Activity单独放入一个栈中，这样这个栈中只有这一个Activity，不同应用的intent都由这个Activity接收和展示，这样就做到了共享。当然前提是这些应用都没有被销毁，所以刚才是按下的HOME键，如果按下了返回键，则无效 android:multiprocess 是否允许多进程，默认是false android:noHistory 当用户从Activity上离开并且它在屏幕上不再可见时，Activity是否从Activity stack中清除并结束。默认是false。Activity不会留下历史痕迹 android:screenOrientation activity显示的模式 默认为unspecified：由系统自动判断显示方向 landscape横屏模式，宽度比高度大 portrait竖屏模式, 高度比宽度大 user模式，用户当前首选的方向 behind模式：和该Activity下面的那个Activity的方向一致(在Activity堆栈中的) sensor模式：有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换 nosensor模式：忽略物理感应器，这样就不会随着用户旋转设备而更改了 android:stateNotNeeded activity被销毁或者成功重启时是否保存状态 android:windowSoftInputMode activity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题，Android1.5后的一个新特性。 这个属性能影响两件事情： 【A】当有焦点产生时，软键盘是隐藏还是显示 【B】是否减少活动主窗口大小以便腾出空间放软键盘 各值的含义： 【A】stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置 【B】stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示 【C】stateHidden：用户选择activity时，软键盘总是被隐藏 【D】stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的 【E】stateVisible：软键盘通常是可见的 【F】stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态 【G】adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示 【H】adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间 【I】adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分 4、第四层intent-filter123456789101112&lt;intent-filter android:icon="drawable resource" android:label="string resource" android:priority="integer" &gt; &lt;action /&gt; &lt;category /&gt; &lt;data /&gt;&lt;/intent-filter&gt; intent-filter属性 android:priority(解释：有序广播主要是按照声明的优先级别，如A的级别高于B，那么，广播先传给A，再传给B。优先级别就是用设置priority属性来确定，范围是从-1000～1000，数越大优先级别越高) Intent filter内会设定的资料包括action,data与category三种。也就是说filter只会与intent里的这三种资料作对比动作 action属性 action很简单，只有android:name这个属性。常见的android:name值为android.intent.action.MAIN，表明此activity是作为应用程序的入口。 category属性 category也只有android:name属性。常见的android:name值为android.intent.category.LAUNCHER(决定应用程序是否显示在程序列表里) data属性 1234567&lt;data android:host="string" android:mimeType="string" android:path="string" android:pathPattern="string" android:pathPrefix="string" android:port="string" android:scheme="string"/&gt; 每个元素指定一个URI和数据类型（MIME类型）。它有四个属性scheme、host、port、path对应于URI的每个部分：scheme://host:port/path scheme的值一般为”http”，host为包名，port为端口号，path为具体地址。如：http://com.test.project:200/folder/etc 其中host和port合起来构成URI的凭据(authority)，如果host没有指定，则port也会被忽略 要让authority有意义，scheme也必须要指定。要让path有意义，scheme+authority也必须要指定 mimeType（指定数据类型），若mimeType为’Image’，则会从content Provider的指定地址中获取image类型的数据。还有’video’啥的，若设置为video/mp4，则表示在指定地址中获取mp4格式的video文件 而pathPattern和PathPrefix主要是为了格式化path所使用的 5、第四层meta-data 123&lt;meta-data android:name="string" android:resource="resource specification" android:value="string"/&gt; 这是该元素的基本结构.可以包含在 四个元素中。 android:name（解释：元数据项的名字，为了保证这个名字是唯一的，采用java风格的命名规范，如com.woody.project.fried) android:resource(解释：资源的一个引用，指定给这个项的值是该资源的id。该id可以通过方法Bundle.getInt()来从meta-data中找到。) android:value(解释：指定给这一项的值。可以作为值来指定的数据类型并且组件用来找回那些值的Bundle方法：[getString],[getInt],[getFloat],[getString],[getBoolean]) 6、第三层属性1234567891011&lt;activity-alias android:enabled=["true" | "false"] android:exported=["true" | "false"] android:icon="drawable resource" android:label="string resource" android:name="string" android:permission="string" android:targetActivity="string"&gt;&lt;intent-filter/&gt; &lt;meta-data/&gt;&lt;/activity-alias&gt; 是为activity创建快捷方式的，如下实例： 123456789101112131415161718192021&lt;activity android:name=".shortcut"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; &lt;activity-alias android:name=".CreateShortcuts" android:targetActivity=".shortcut" android:label="@string/shortcut"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.CREATE_SHORTCUT" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/activity-alias&gt; 其中android.targetActivity是指向对应快捷方式的activity,如上述的shortcut(此Activity名) android:label是指快捷方式的名称，而快捷方式的图标默认是给定的application图标 7、第三层 service 【1】service与activity同级，与activity不同的是，它不能自己启动的，运行在后台的程序，如果我们退出应用时，Service进程并没有结束，它仍然在后台运行。比如听音乐，网络下载数据等，都是由service运行的 【2】service生命周期：Service只继承了onCreate(),onStart(),onDestroy()三个方法，第一次启动Service时，先后调用了onCreate(),onStart()这两个方法，当停止Service时，则执行onDestroy()方法，如果Service已经启动了，当我们再次启动Service时，不会在执行onCreate()方法，而是直接执行onStart()方法 【3】service与activity间的通信 Service后端的数据最终还是要呈现在前端Activity之上的，因为启动Service时，系统会重新开启一个新的进程，这就涉及到不同进程间通信的问题了(AIDL)，Activity与service间的通信主要用IBinder负责。【4】 123456789101112131415&lt;service android:enabled=["true" | "false"] android:exported[="true" | "false"] android:icon="drawable resource" android:label="string resource" android:name="string" android:permission="string" android:process="string"&gt;&lt;/service&gt; service标签内的属性之前已有描述，在此不重复了～ 8、第三层 receiver的属性与service一样，这里就不显示了 BroadcastReceiver：用于发送广播，broadcast是在应用程序之间传输信息的一种机制，而BroadcastReceiver是对发送出来的 Broadcast进行过滤接受并响应的一类组件。9、第三层属性 contentProvider(数据存储) 【1】android:authorities： 标识这个ContentProvider，调用者可以根据这个标识来找到它 【2】android:grantUriPermission： 对某个URI授予的权限 【3】android:initOrder 10、第三层 用户库，可自定义。所有android的包都可以引用 11、第一层 这是在android1.6以后的新特性，支持多屏幕机制 各属性含义：这四个属性，是否支持大屏，是否支持中屏，是否支持小屏，是否支持多种不同密度 12、第二层 uses-configuration 与uses-feature性能都差不多 123456789&lt;uses-configuration android:reqFiveWayNav=["true" | "false"] android:reqHardKeyboard=["true" | "false"] android:reqKeyboardType=["undefined" | "nokeys" | "qwerty" | "twelvekey"] android:reqNavigation=["undefined" | "nonav" | "dpad" | "trackball" | "wheel"] android:reqTouchScreen=["undefined" | "notouch" | "stylus" | "finger"] /&gt;&lt;uses-feature android:glEsVersion="integer" android:name="string" android:required=["true" | "false"] /&gt; 这两者都是在描述应用所需要的硬件和软件特性，以便防止应用在没有这些特性的设备上安装。 13、第二层uses-sdk123&lt;uses-sdk android:minSdkVersion="integer" android:targetSdkVersion="integer" android:maxSdkVersion="integer"/&gt; 描述应用所需的api level，就是版本，目前是android 2.2 = 8，android2.1 = 7，android1.6 = 4，android1.5=3 在此属性中可以指定支持的最小版本，目标版本以及最大版本 14、第二层instrumentation123456&lt;instrumentation android:functionalTest=["true" | "false"] android:handleProfiling=["true" | "false"] android:icon="drawable resource" android:label="string resource" android:name="string" android:targetPackage="string"/&gt; 定义一些用于探测和分析应用性能等等相关的类，可以监控程序。在各个应用程序的组件之前instrumentation类被实例化 android:functionalTest(解释：instrumentation类是否能运行一个功能测试，默认为false) 15、permission、uses-permission、permission-tree 、permission-group 区别～ 最常用的当属，当我们需要获取某个权限的时候就必须在我们的manifest文件中声明，此与同级，具体权限列表请看此处 通常情况下我们不需要为自己的应用程序声明某个权限，除非你提供了供其他应用程序调用的代码或者数据。这个时候你才需要使用 这个标签。很显然这个标签可以让我们声明自己的权限。比如： 那么在activity中就可以声明该自定义权限了，如： 1234567&lt;application . . .&gt; &lt;activity android:name="XXX" . . . &gt; android:permission="com.teleca.project.MY_SECURITY"&gt; &lt;/activity&gt; &lt;/application&gt; 当然自己声明的permission也不能随意的使用，还是需要使用来声明你需要该权限 就是声明一个标签，该标签代表了一组permissions，而是为一组permissions声明了一个namespace。这两个标签可以看之前的系列文章。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何提高Android虚拟机的运行速度]]></title>
      <url>%2F2016%2F07%2F17%2F%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98Android%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[关于Android virtual DeviceAndroid virtual Device（AVD）是Google推出的可以在x86,x64,AMD设备上运行的虚拟机。我们可以在Android Studio中创建并且使用。 在我们一般创建时，都再用默认的设置，这样会导致AVD使用时很卡，卡到爆…… 下面我们就来一起设置，使它流畅的运行起来。 下载安装Intel HAXM 打开SDK Manger，在SDK Tools目录下，选择并下载Intel HAXM。 下载好并不代表安装，我们需要打卡SDK目录进行安装。 …\extras\intel\Hardware_Accelerated_Execution_Manager\intelhaxm-android.exe 安装只需要next就好。也可以适当的分配一点大的内存。 重启你的电脑。 添加AVD我们打开AVD Manager。行创建一个AVD 行创建一个AVD 选择一个你喜欢的机型，我在这里选择6P。 按照你的电脑选择API和ABI Next-&gt;Finish 此时我们就添加好一个虚拟机了。 运行并修改参数我们点击运行 此时我们需要观察Android Studio的输出日志。其中有一条值得我们注意 这一条警告提示我们VM heap低于最低值384M，要求我们去设置为384M。 此时我们打开编辑，修改VM heap为他所要求的值，我们的AVD就可以流畅的运行了。 基于Android Studio 2.1，Intel X64 RAM 8G]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Activity启动的两种方式]]></title>
      <url>%2F2016%2F07%2F04%2FActivity%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[今天学习Android的Intent的使用 显示使用显示Intent就是指定Activity。 123456789101112131415161718192021222324package com.example.myapplication;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btnStartMyAty).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; startActivity(new Intent(MainActivity.this, MyAty.class)); &#125; &#125;); &#125;&#125; 通过Intent直接指定一个Activity 隐式Intent创建一个Intent，但是并不指定启动的Activiy，有很多启动方式。 配置AndroidManiFest.xml中的activity AndroidManiFest.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.myapplication"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".MyAty"&gt; &lt;intent-filter&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;action android:name="asdasd"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 在AndroidManiFest.xml中配置文件，添加intent-filter标签，并添加一个字符串。 MainActivity.java 123456789101112131415161718192021222324package com.example.myapplication;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btnStartMyAty).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //直接通过字符串启动 startActivity(new Intent("asdasd")); &#125; &#125;); &#125;&#125; 注意这里的字符串虽然可以说是任意格式，但是有一个约定俗成的规定包名.intent.action.Action名 所以上述的asdasd我们应该命名为com.example.myapplication.intent.activity.MyAty为了方便，我们不出错。我们会在代码的前面的添加一个静态常量。 MyAty.java 1234567891011121314151617181920package com.example.myapplication;import android.app.Activity;import android.os.PersistableBundle;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MyAty extends Activity &#123; public static final String ACTION = "com.example.myapplication.intent.activity.MyAty"; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123; super.onCreate(savedInstanceState, persistentState); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_aty); &#125;&#125; MainActivity.java 1234567891011121314151617181920212223package com.example.myapplication;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btnStartMyAty).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; startActivity(new Intent(MyAty.ACTION)); &#125; &#125;); &#125;&#125; 这样就很方便的使用，让我们不出错。 优势：可以启动其他应用的页面，如在A应用中启动B应用中的某个Actio。Demo 新建一个Module。 MainActivity.java 12345678910111213141516171819202122package com.example.app1;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btnStartMyaty).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 通过字符串直接启动另一个app的页面。 startActivity(new Intent("com.example.myapplication.intent.activity.MyAty")); &#125; &#125;); &#125;&#125; Intent过滤器多个Activity拥有同一个Intent Action新建Activity命名为MyAct1之后的代码一样 AndroidManiFest.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.myapplication"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".MyAty" android:label="MyAty"&gt; &lt;intent-filter&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;action android:name="com.example.myapplication.intent.activity.MyAty" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".MyAty1" android:label="@string/title_activity_my_aty1"&gt; &lt;intent-filter&gt; &lt;category android:name="android.intent.category.DEFAULT"&gt;&lt;/category&gt; &lt;action android:name="com.example.myapplication.intent.activity.MyAty"&gt;&lt;/action&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 此时我们在运行启动。 会弹出提示，让我们选择启动哪一个Activity。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java集合遍历]]></title>
      <url>%2F2016%2F05%2F23%2FJava%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%2F</url>
      <content type="text"><![CDATA[集合的遍历使用IteratorIterator主要用于遍历集合中的Collection元素，因此Iterator创建的对象是一个迭代器。 Iterator提供的四个方法 boolean hasNext(): 如果迭代器的集合还没有被遍历完，返回ture。 Object next():返回集合里的下一个元素。 void remove():删除集合里上一次next方法返回的元素。 void forEachRemaining(Consumer action)：这个是java 8为Iterator新增的默认方法，该方法可使用Lambda表达式遍历所有的集合元素。 next方法1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * Created by 晓辉 on 2016/5/23. * 使用jdk8中的iterator遍历集合； */public class IteraorTest &#123; public static void main(String[] args) &#123; List books=new ArrayList&lt;&gt;(); books.add("fengk"); books.add("niaho"); Iterator it=books.iterator(); while (it.hasNext())&#123; it.next(); if(books.equals("fengk"))&#123; it.remove(); &#125; System.out.println(it.next()); &#125; &#125;&#125;&gt; 输出结果&gt;niaho Iterator只用于遍历集合，本身本身并不具有承装对象的能力。如果需要就要创建Iterator对象，则必须有一个被迭代的集合。Iterator必须依附于Collection对象，若有一个Iterator对象，则必然有一个与之关联的Collection对象。 使用Lambda表达式遍历Iterator123456789101112131415161718import java.util.Collection;import java.util.HashSet;import java.util.Iterator;/** * Created by 晓辉 on 2016/5/23. */public class IteratorEach &#123; public static void main(String[] args) &#123; // 创建一个集合 Collection books=new HashSet&lt;&gt;(); books.add("java"); books.add("c#"); Iterator it=books.iterator(); // 使用Lambda表达式遍历所有的集合 it.forEachRemaining(obj-&gt;System.out.println(obj)); &#125;&#125; 输出结果c#java 注意：这里的输出是倒序。 ##使用foreach遍历集合元素123456789101112131415161718192021import java.util.Collection;import java.util.HashSet;import java.util.Iterator;public class ForeachTest &#123; public static void main(String[] args) &#123; // 创建一个集合 Collection books=new HashSet&lt;&gt;(); books.add("java"); books.add("c#"); for(Object obj:books)&#123;// 此处的books变量也不是集合的本身元素 String book=(String)obj; System.out.println(book); if (book.equals("java"))&#123; books.remove(book); &#125; &#125; System.out.println(books); &#125;&#125; for循环中的迭代变量也不是集合元素本身，系统只是以此把集合元素的值赋值给迭代变量，因此for循环中修改的迭代变量的值是也是没有任何意义。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub for windows使用教程（三）]]></title>
      <url>%2F2016%2F05%2F15%2FGitHub-for-windows%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[团队协作流程认识FlowGitHub Flow是一个轻量级的，基于分支的工作流程，支持团队和部署在那里的定期做项目。 为团队成员写入权限在我们的队友添加一个写的权限，这样我们的队友才能很好的修改代码。我们打开网页上的GitHub,点击settings, 之后我们找到collaborators，这里会让我们验证密码，之后就有添加合作者的选项。这样我们就能添加我们的小伙伴了！ 这样我们就添加了新的小伙伴，新的小伙伴有着同样的权限去修改和管理代码。此时我们就会看到我的小伙伴wevan的github主页上就会出现关于我创建的First的各种通知。 创建分支在我们创建一个叫add new function的分支。 创建一个分支 Create a branch 当你工作的一个项目，你会在任何给定的时间有一堆不同的功能或正在进行的想法 - 其中一些是蓄势待发，而另一些则不是。分支的存在是为了帮助你管理这个工作流程。 When you’re working on a project, you’re going to have a bunch of different features or ideas in progress at any given time – some of which are ready to go, and others which are not. Branching exists to help you manage this workflow. 当您在项目中创建一个分支，你创造一个环境，在那里你可以尝试新的想法。你让一个分支的更改不会影响主分支，让你可以自由进行实验，并提交更改，在你的分支将不会被合并，直到它准备好知识安全的人所正在与合作进行审查。 When you create a branch in your project, you’re creating an environment where you can try out new ideas. Changes you make on a branch don’t affect the master branch, so you’re free to experiment and commit changes, safe in the knowledge that your branch won’t be merged until it’s ready to be reviewed by someone you’re collaborating with. ProTip 分支在Git中是一个核心概念，整个GitHub的流量是基于它。这里只有一个规则：在任何主分支总是部署。 Branching is a core concept in Git, and the entire GitHub Flow is based upon it. There’s only one rule: anything in the master branch is always deployable. 正因为如此，这是非常重要的一个功能或修复工作时，你的新分支关老爷的创建。您的分支名应该是描述（例如，重构的身份验证，用户的内容缓存键，使视网膜-化身），以便其他人可以看到正在处理。 Because of this, it’s extremely important that your new branch is created off of master when working on a feature or a fix. Your branch name should be descriptive (e.g., refactor-authentication, user-content-cache-key, make-retina-avatars), so that others can see what is being worked on.来自GitHub Flow 添加提交 我们首先把分支切换到新的分支上add new function 修改新的版本 填写好新的Summary和Description，提交新的版本并同步。这样小伙伴登陆到GitHub上就看到了就可以清楚的看到一切的修改。 添加提交 Add commits 一旦你的分支已经建立，现在是时候开始进行更改。无论何时添加，编辑或删除一个文件，你作出承诺，并将其添加到您的分支。提交加入这一过程保持你的进步轨迹，你在一个特性分支工作。 Once your branch has been created, it’s time to start making changes. Whenever you add, edit, or delete a file, you’re making a commit, and adding them to your branch. This process of adding commits keeps track of your progress as you work on a feature branch. 还承诺创建工作的透明历史，其他人可以按照理解你做了什么，以及为什么。每次提交都有一个关联的提交信息，这是解释为什么一个特定的变化作出了说明。此外，每次提交被认为是变革的一个独立单元。这使您可以回滚的变化，如果发现错误，或者如果你决定在一个不同的方向前进。 Commits also create a transparent history of your work that others can follow to understand what you’ve done and why. Each commit has an associated commit message, which is a description explaining why a particular change was made. Furthermore, each commit is considered a separate unit of change. This lets you roll back changes if a bug is found, or if you decide to head in a different direction. ProTip 提交信息是重要的，特别是因为Git跟踪更改，然后将它们显示为承诺一旦他们推到服务器。通过字迹清晰提交信息，你可以更容易为其他人跟着，并提供反馈。 Commit messages are important, especially since Git tracks your changes and then displays them as commits once they’re pushed to the server. By writing clear commit messages, you can make it easier for other people to follow along and provide feedback.来自GitHub Flow 打开一个pull请求这个是整个流程中比较关键的一步，发布Pull Request。点击客户端或者网页上的Pull Request发布。我们这里点击Pull Request我们填写好必要的说明性文字点击Send Pull Request他既然让我们到GitHub上看，我们就听他的，点击，进入。我们发现小伙伴已经在下面留言了！ 讨论和审核你的代码你的小伙伴开始对你的代码讨论，修改，迭代。 讨论和审查你的代码 Discuss and review your code 一旦拉入请求已被打开，人或团队审查您的变化可能有疑问或意见。也许编码风格不匹配项目的指导方针，改变缺少单元测试，或者也许一切看起来不错，道具都是为了。引入请求旨在鼓励并捕获这种类型的对话。 Once a Pull Request has been opened, the person or team reviewing your changes may have questions or comments. Perhaps the coding style doesn’t match project guidelines, the change is missing unit tests, or maybe everything looks great and props are in order. Pull Requests are designed to encourage and capture this type of conversation. 您还可以继续推送到你的分支在你提交的讨论和反馈光。如果有人评论说，你忘了做某件事，或者如果在代码中的错误，你可以在你的分支修复它，推高的变化。GitHub上会显示新的提交和其他任何意见，你可能会收到统一拉请求视图。 You can also continue to push to your branch in light of discussion and feedback about your commits. If someone comments that you forgot to do something or if there is a bug in the code, you can fix it in your branch and push up the change. GitHub will show your new commits and any additional feedback you may receive in the unified Pull Request view. ProTip 拉请求的意见都写在降价，所以你可以插入图片和表情符，使用预先格式化的文本块，等轻质格式。 Pull Request comments are written in Markdown, so you can embed images and emoji, use pre-formatted text blocks, and other lightweight formatting. 部署 部署 Deploy 一旦你拉的请求进行了审查和部门通过你的测试，您可以部署您的更改，以验证他们的生产。如果你的分支造成的问题，您可以通过部署现有的主投产回滚 Once your pull request has been reviewed and the branch passes your tests, you can deploy your changes to verify them in production. If your branch causes issues, you can roll it back by deploying the existing master into production. 合并合并分支我们之前已经说过，这里就不再赘述。 合并 Merge 现在，您的更改在生产中得到了验证，现在是时候你的代码合并到主分支。 Now that your changes have been verified in production, it is time to merge your code into the master branch. 合并后，引入请求保护的历史变迁到您的代码记录。因为他们是搜索的，他们不让任何人回去的时间理解为什么以及如何决定了。 Once merged, Pull Requests preserve a record of the historical changes to your code. Because they’re searchable, they let anyone go back in time to understand why and how a decision was made. ProTip 通过将某些关键字到您的拉请求的文本，你可以用代码相关联的问题。当你拉入请求合并，相关问题也将被关闭。例如，输入短语关闭＃32将关闭在仓库中发行数量32。欲了解更多信息，请查看我们的帮助文章。 By incorporating certain keywords into the text of your Pull Request, you can associate issues with code. When your Pull Request is merged, the related issues are also closed. For example, entering the phrase Closes #32 would close issue number 32 in the repository. For more information, check out our help article. 注意：英文翻译为机器翻译，可能有翻译错误的地方，建议大家尽可能看英文 总结基本的GitHub教程就算写完了，已有如果在有就是一些GitHub上的一些使用小技巧了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub for Windows使用教程(二)]]></title>
      <url>%2F2016%2F05%2F13%2FGitHub-for-Windows%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B(%E4%BA%8C)%2F</url>
      <content type="text"><![CDATA[分支的使用创建分支我们创建第一个分支取名为“new masterh”,点击Create new branch创建第一个分支。 我们发现此时的分支已经切换到了我们刚刚创建的分支new masterch 我们来修改new masterch分支上的内容。我们仍旧打开FirstDemo.txt进行编辑。输入以下内容 创建的第一个分支。 打开github进行，填写Summary和Description 之后我们点击Commit to new-master在History目录下，我们可以看到会有两条主线，分别是master和new-master并且在new-master的分支下又一个蓝色的实线空心圈和一个虚线空心圈。实线圈表示当前的节点，空心圈表示下一次修改时的节点。红线标示的部分就是当前的分支 切换分支点击红色划线部分就会出现分支的列表我们点击master就会切换到master分支。 上传/同步分支这个操作和同步仓库是一个操作，点击Publish/Sync上传或同步分支。 删除分支首先要把分支切换到你要删除的分支下，如我们要删除new master，将分支切换到new master点击右上角齿轮就会出现Delete new master 点击Delete new master就会弹出一个对话框，询问删除的内容。 第一个yes ，Delete both是将本地与网页全部删除；第二个Delete local only仅仅是删除本地。第三个是取消。 合并两个分支将一个分支与master分支进行合并。我们首先把分支切换到master下，点击Update from new-branch进行分支的合并。 此时我们查看history目录下就会]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub for Windows使用教程（一）]]></title>
      <url>%2F2016%2F05%2F03%2FGitHub-for-Windows%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[前言鉴于网上目前的教材都太落后，github for windows已经更新了多个版本，好多界面都发生了变化，所以来写这个教程。目的是为了帮助和我一样初学github，但是苦于找不到教程的同学，为了写最详细的教程。配备了大量的图文介绍。该教程是基于GitHub for windows (3.0.17.0) 什么是Github说到什么事github，我们先看wikipedia的描述“GitHub是一个利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务。它由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。” 准备工作 下载github for windows，安装这里不赘述。 注册github账号 登陆到github for windows。 准备工作都完了，我们开始正式学习。^_^ 创建第一个代码库认识界面 github for windows的界面非常清爽，的确符合geek的性质，个人表示非常喜欢。我们来建立第一个仓库，点击左上角的+号，初次建立他会有一圈圈的涟漪，非常漂亮哦。打开之后有三个选项，Add，Create，Clone。我们分别来介绍一下这三个功能。 Add功能如果本地有工程，就可以使用Add添加 Clone功能这个功能其实最好理解了，克隆这名字通俗易懂好理解。如何使用Clone功能呢？ 就是将在浏览器上已经创建好的项目导入到本地，换句话说就是下载到本地。 Create功能创建一个代码库，Name填写你的仓库名字。Local path写你将要保存在本地路径。我们主要从这个功能开始github之旅。 我们在这里填写First，来创建第一个我们自己的repository。 开始使用第一个代码库修改第一个代码库中内容我们来找到刚刚创建的代码库在本地的位置。就是刚刚在local path的地址路径，当然如果你忘了，请右键点击First。选择Open in Explorer。这样我们就可以转到刚刚的路径下。我们新建一个文本文档。在里面编辑。如下此时的github就会变成这个样子(Changs)：你会发现此时github会出现刚刚编辑的内容。 这个是测试文本 你好并且前面会有蓝色标识，那么这个蓝色标识是什么用呢？其实这个蓝色标识是提示你会上改变的文本。比如我第一次只想改变这个是测试文本并不想把你好上传。这时我们点击一下你好的前面的蓝色标识。 你会发现你好前面的蓝色标识没有了。我们填写好Summer和DescriptionSummer就是这次改动的总结，我们也可以理解为标题（必填），而Description可以理解为详细概况（选填） 我们这里只选择第一个修改对象，也就是这个是测试文本就行修改。summer我们填写为第一次修改，Description我们填写为增加了这个是测试文本的内容，之后点击Commit to master。 切换到History目录下 我们会发现他改变了。这次我们把你好进行添加。 在History目录下发生了这样的改变。会在History目录下形成一天时间线，来指出每一次的修改标题和内容，同时会把修改的内容用绿色标识标出。我们打开本地的文本，删除刚刚添加的第一行这个是测试文本。 此时你就会发现github发生了变化。很多人说这里会出现乱码,这个是编码问题,如果不修改编码,只是在客户端上显示乱码,但是上传后不会出现乱码,为了保险起见,建议大家还是把文本编码修改为 utf-8 . 此时的红色标识标识删除。我们写好Summer和Description并点击Commit to master。这样我们就删除了第一行。同时在History目录下又多了一条时间轴。 这样我们就完成了删除。 上传与同步上传此时，当我们打开github网页，就会发现此时你的修改的内容并没有出现在这里。这是因为你没有进行同步，仅仅是在本地就行了修改。此时我们仅仅需要点击右上角的publish 此时你就会本地内容已经上传到网页上。 同步当你的代码库上传后就会发现，原来的publish以及变为了Sync。 点击Sync同步代码库！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大学？大学？大学？]]></title>
      <url>%2F2016%2F04%2F27%2F%E5%A4%A7%E5%AD%A6%EF%BC%9F%E5%A4%A7%E5%AD%A6%EF%BC%9F%E5%A4%A7%E5%AD%A6%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[大学？大学？ 大学？仅仅写给自己 第一篇生活在这个大学里那种迷茫有时候只有自己知道，有时候的动力其实是为0的，只能按照自己的想法去走，可是一个人搞了两个晚上的东西，还是没有成功，有些事情只能自己去做，没人会对自己的事情感兴趣，更不会去帮你。当一个问题查阅了百度，google后仍旧没有解决，那种失落或许没人能懂！连续两个晚上都在弄，看来百度，查了google，连youtube上的视频看了，然而问题依旧，只能靠自己慢慢去搞。然而MinwgM，Cmake对于一个刚刚接触软件工程的人来说，没有任何人的帮助，自己慢慢的去看，略知皮毛，然而Clion的报错让我已经筋疲力尽。昨晚开始配置Clion，从MinWG开始，然后是Cmake，都是一个个的新名词，一次又一次的失败W，刚刚开始连Cmake都无法使用，后来helloworld都无法运行。这次是MinGM的报错，百度了，google了，看了youtube，这个问题不是我一个人遇到，然而我却看不到解决的方法，满是英文的屏幕看的非常吃力，当没有答案时，只能自己去创造答案。自己一个人去看报错的文档，然而我又一次高估了自己的能力……晦涩难懂的英文和路径，一头雾水。同时IDEA也让我感到了无力，深深的无力。为什么，他们家的IDE要让开发者把时间都放在大量的配置上去。最后还是投靠了eclipse。但让clion我会继续研究下去的。 或许有时候是太高估自己了，要走和别人不一样的道路，就用个编译器都要标新立异。从github+hexo的博客搭建到今天的Clion和Idea，真的很浪费时间，收获感觉微乎其微，达不到什么实质性的东西，包括现在学习github，好像是一个错误的想法，而且重要的是把别人往沟里带，让别人按自己的想法走，多可笑啊。是该好好整理一下自己的想法了，有时候该问问那些过来的人，多听听他们的建议，不要给自己多走弯路。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LinkList特有的方法]]></title>
      <url>%2F2016%2F04%2F23%2FLinkList%E7%89%B9%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[LinkList特有的方法 addFirst();addLast(); 添加元素，第一个或最后一个。 getList();getFirst(); 获取元素，但是不会删除。如果集合中没有元素，会抛出NoSuchElementException。 removeFirst();removeLast(); 获取元素，但是元素被删除。如果集合中没有元素，就会出现NoSuchElementException。 在jdk1.6中出现了替代的方法： offerFirst(); offerLast(); 添加元素。 peekFirst();peekLast(); 获取元素，但是元素不被删除。如果集合中没有元素，会返回null。 pollFirst();pollLast(); 获取元素，但是元素被删除。如果集合中没有元素，会返回null。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[清除右键无效项]]></title>
      <url>%2F2016%2F04%2F21%2F%E6%B8%85%E9%99%A4%E5%8F%B3%E9%94%AE%E6%97%A0%E6%95%88%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[清除右键无效项 前言有时在安装一些程序时，当程序卸载后会留下一些右键无效项，对于强迫症处女座来说，这是一件万万不能的。 开始 新建一个文本文档，复制下面的代码到文本里 12345678910111213141516@ ECHO OFF@ ECHO.@ ECHO.@ ECHO. 说 明@ ECHO -----------------------------------------------------------------------@ ECHO @ ECHO 可能杀毒软件会提示威胁项，允许运行就好！@ ECHO @ ECHO -----------------------------------------------------------------------@ Echo.PAUSEregsvr32 /u /s igfxpph.dllreg delete HKEY_CLASSES_ROOT\Directory\Background\shellex\ContextMenuHandlers /freg add HKEY_CLASSES_ROOT\Directory\Background\shellex\ContextMenuHandlers\new /ve /d &#123;D969A300-E7FF-11d0-A93B-00A0C90F2719&#125;reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v HotKeysCmds /freg delete HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v IgfxTray /f 将文本的后缀改为.cmd。 双击运行这个脚本。此时，你就会发现那些没用的右键选项都没有了 ^ ^]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一次参加蓝桥杯感受]]></title>
      <url>%2F2016%2F04%2F21%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%82%E5%8A%A0%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%84%9F%E5%8F%97%2F</url>
      <content type="text"><![CDATA[作为一名大一新生，这是我第一次参加这样的比赛，比赛前也没要指望要得什么奖项，抱着锻炼的态度，还好有所收获。 下面会列出我做的题和做题时的感受 1.煤球数目有一堆煤球，堆成三角棱锥形。具体： 第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），….如果一共有100层，共有多少个煤球？请填表示煤球总数目的数字。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 这个题的第一反应我是用excel做，用excel生成有序的数列，结果建立了excel后出现的是小树，瞬间懵逼…………只好一步一步的写代码，按理说这应该是一个简单的代码，可是我还是写错了，在我记忆里好像写的是5050……额，好心痛…… 2.生日蜡烛某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。现在算起来，他一共吹熄了236根蜡烛。请问，他从多少岁开始过生日party的？请填写他开始过生日party的年龄数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 这个题的第一反应还是excel表，最后我的确是用excel做出来了，也是这次比赛中唯一做对的题目。虽然用excel比较麻烦，但是对于我这种第一时间没有一个很好的明确思路的我来说，这样很快。 3.凑算式这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。这个算式一共有多少种解法？注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。 很简单的暴力求解，为什么我没有做对呢…………开始的时候题的要求是0~9，后来改为1~9，可惜，我们考场没有收到任何通知…………我按0~9算的……悲哀的人生 做到这里的时候好像时间就过去了一个半小时了，实在是太慢了，也侧面说面对算法不熟练…… 4.快速排序排序在各种场合经常被用到。快速排序是十分常用的高效率的算法。其思想是：先选一个“标尺”，用它把整个队列过一遍筛子，以保证：其左边的元素都不大于它，其右边的元素都不小于它。这样，排序问题就被分割为两个子区间。再分别对子区间排序就可以了。下面的代码是一种实现，请分析并填写划线部分缺少的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;void swap(int a[], int i, int j)&#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125;int partition(int a[], int p, int r)&#123; int i = p; int j = r + 1; int x = a[p]; while(1)&#123; while(i&lt;r &amp;&amp; a[++i]&lt;x); while(a[--j]&gt;x); if(i&gt;=j) break; swap(a,i,j); &#125; ______________________; return j;&#125;void quicksort(int a[], int p, int r)&#123; if(p&lt;r)&#123; int q = partition(a,p,r); quicksort(a,p,q-1); quicksort(a,q+1,r); &#125;&#125;int main()&#123; int i; int a[] = &#123;5,13,6,24,2,8,19,27,6,12,1,17&#125;; int N = 12; quicksort(a, 0, N-1); for(i=0; i&lt;N; i++) printf("%d ", a[i]); printf("\n"); return 0;&#125; 其实第一眼看到快速排序就有点后悔，因为之前看过，但是没有记住，当时并没有重视。so，这个题自然是做错了。 ##5.抽签X星球要派出一个5人组成的观察团前往W星。其中：A国最多可以派出4人。B国最多可以派出2人。C国最多可以派出2人。….那么最终派往W星的观察团会有多少种国别的不同组合呢？下面的程序解决了这个问题。数组a[] 中既是每个国家可以派出的最多的名额。程序执行结果为：DEFFFCEFFFCDFFFCDEFFCCFFFCCEFFCCDFFCCDEFBEFFFBDFFFBDEFFBCFFFBCEFFBCDFFBCDEF….(以下省略，总共101行) 没做出来 6.方格填数填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）一共有多少种可能的填数方案？请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 这个题我是把每个格子标了序号，用暴力求解满足条件，好像我算的是400。额，有错了，好吧，我仅仅是做到这里。 虽然我没有做完吧，甚至只做对了一道题，但是我想说，大一才刚刚开始，权当锻炼，而且还有很大的收获，以后要努力喽。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我一直都在]]></title>
      <url>%2F2016%2F04%2F20%2F%E6%88%91%E4%B8%80%E7%9B%B4%E9%83%BD%E5%9C%A8%2F</url>
      <content type="text"><![CDATA[我没有最烈的酒，我没有阳光和宇宙。讲真儿，我从来没走，所以也不需要留。我在你身后。不要愁，不要愁，风雨与你共舟 谢谢你！加油，共勉！]]></content>
    </entry>

    
  
  
</search>
